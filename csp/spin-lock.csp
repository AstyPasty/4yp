-- A lock based upon the test-and-set operation with fixed-time backoff.
--  * Based on Herlihy & Shavit, Section 7.4. 
--  * @param delay the time in nanoseconds to delay when conflict detected.


datatype Variable = State
datatype ThreadID = T0 | T1 | T2 | T3 | T4 


channel atomic: Variable
channel delay: ThreadID
channel tryLock: ThreadID
channel lock : ThreadID
channel getAndSet: ThreadID.Variable.Bool
channel get: ThreadID.Variable.Bool
channel set: ThreadID.Variable.Bool
channel enteringLock: ThreadID
channel exitingLock: ThreadID
channel exitedLock: ThreadID


Atomic :: Proc
Atomic = atomic?v -> atomic!v -> Atomic




Spin = delay?t -> Spin

BoolVar :: (Variable, Bool) -> Proc

BoolVar(me, v) = getAndSet?t!me?value -> getAndSet!t!me!v -> BoolVar(me, value)
            []   get?t!me?_ -> get!t!me!v -> BoolVar(me, v)
            []   set?t!me?b -> set!t.me!b -> BoolVar(me, b)


Lock :: (ThreadID) -> Proc
Lock(t) =  get!t.State.True -> get!t.State?c -> if c == True then Lock(t) -- while(state.get()){ }
           else getAndSet!t.State.True -> getAndSet!t.State?v -> if v == False then Holding(t) -- if(! state.getAndSet(true)) done = true
           else delay!t -> Lock(t)

Unlock :: (ThreadID) -> Proc
Unlock(t) = exitingLock!t -> set.t.State!False -> exitedLock!t -> set.t.State?v -> if v == False then NotHolding(t) else DIV-- def unlock = state.set(false)

TryLock :: (ThreadID) -> Proc
TryLock(t) = get!t.State.True -> get!t.State?s -> if s == True then NotHolding(t) else getAndSet!t.State.True -> getAndSet!t.State?v -> if v == True then NotHolding(t) else Holding(t)  --!state.get && !state.getAndSet(true)

Holding(t) = enteringLock!t -> Unlock(t)

NotHolding(t) = TryLock(t) |~| Lock(t)

AtomicCheck :: (Bool) -> Proc
AtomicCheck(b) = [] t : ThreadID @ AtomicThread(b, t)
AtomicThread :: (Bool, ThreadID) -> Proc
AtomicThread(b, t) = if b ==  True then (get!t.State.True -> get!t.State?True -> AtomicCheck(True)
                     [] set!t.State.True -> set!t.State?True -> AtomicCheck(True)
                     [] set!t.State.False -> set!t.State?False -> AtomicCheck(False)
                     [] getAndSet!t.State.True -> getAndSet!t.State?True -> AtomicCheck(True)
                     [] getAndSet!t.State.False -> getAndSet!t.State?True -> AtomicCheck(False))
                     else (get!t.State.True -> get!t.State?False -> AtomicCheck(False)
                     [] set!t.State.True -> set!t.State?True -> AtomicCheck(True)
                     [] set!t.State.False -> set!t.State?False -> AtomicCheck(False)
                     [] getAndSet!t.State.True -> getAndSet!t.State?False -> AtomicCheck(True)
                     [] getAndSet!t.State.False -> getAndSet!t.State?False -> AtomicCheck(False))



AllThreads = ||| t : ThreadID @ NotHolding(t)
Components = Spin ||| BoolVar(State, False)
AllChannels = {|get, set, getAndSet, delay|}


ActualSystem = (AllThreads [|AllChannels|] Components)

-- Obvious
assert ActualSystem :[divergence free]
assert ActualSystem :[deadlock free]
-- Check that all operations on state are seemingly atomic
assert AtomicCheck(False) [T= ActualSystem\{|delay, enteringLock, exitingLock, exitedLock|}

CheckMutualExclusion = enteringLock?t -> exitingLock?t -> exitedLock?t -> CheckMutualExclusion
-- Check that no two threads hold the lock at the same time
assert CheckMutualExclusion [T= ActualSystem\{|get, set, getAndSet, delay|}

CheckNoExtraSpins :: ({ThreadID}) -> Proc
CheckNoExtraSpins({}) = exitedLock?t -> delay?u -> CheckNoExtraSpins({u})
CheckNoExtraSpins(xs) = delay?y -> if card(inter(xs, {y})) == 0 then CheckNoExtraSpins(union({y}, xs)) else DIV

assert CheckNoExtraSpins({})[|{|exitedLock, delay, enteringLock|}|]ActualSystem :[divergence free]


-- Force multiple communications to occur sequentially
