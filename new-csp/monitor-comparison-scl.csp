n = 5
datatype ThreadID = T.{0..n-1}
datatype SignalID = S.{0}--..n-1}
datatype MonitorID = SigM.SignalID
datatype ConditionID = C.{0..2}


-- This will include the version of the SCL monitor based on a 
-- ParkSupport implementation
include "scl-monitor-simplified.csp"

instance SCL = SCLMonitor


-- A very general correct usage of either an SCL or JVM monitor
-- Threads here aren't allowed to terminate; this could be modified to
-- include that but I don't feel like theres much to gain from it

-- TODO: parametise over ConditionID correctly
ThreadSCL(t) = SCL::Lock(SigM.S.0, t); ThreadSCL1(t)
ThreadSCL1(t) =   
  [] c : ConditionID @ (SCL::Await(SigM.S.0, c, t); ThreadSCL1(t))      
  [] (SCL::Signal(SigM.S.0, c, t); ThreadSCL1(t))
  [] (SCL::Signal(SigM.S.0, c, t); ThreadSCL1(t))
  [] (SCL::SignalAll(SigM.S.0, c, t); ThreadSCL1(t))
  [] (SCL::Unlock(SigM.S.0, t); ThreadSCL(t))

 


-- Initialise systems of multiples of the threads above operating on 
-- the same monitor in parallel. Note that here we block spurious wakeups

ThreadsSCL = ||| t<-ThreadID @ ThreadSCL(t)

-- The Det system blocks spurious wakeups, the other one allows them
SCLSystem = SCL::runWith(ThreadsSCL, SigM.S.0, ConditionID)
SCLSystemDet = SCL::runWithDet(ThreadsSCL, SigM.S.0, ConditionID)


-- The specification process for a monitor with multiple conditions

init = mapFromList(<(c, <>) | c <- seq(ConditionID)>)
values(map) = Union({set(mapLookup(map, cnd)) | cnd <- ConditionID})

SpecUnlocked'(m, waiting, poss) =
     SCL::callAcquire.m?t':diff(ThreadID, union(values(waiting), poss)) ->
       SpecUnlocked'(m, waiting, union(poss,{t'}))
  [] SCL::acquire.m?t:poss -> SpecLocked'(m, t, waiting, diff(poss,{t}))
     

SpecLocked'(m, t, waiting, poss) =
     SCL::callAwait.m?c:ConditionID!t -> 
       SpecLockedWaiting'(m, c, t, waiting, poss)
  [] SCL::callSignal.m?c:ConditionID!t -> 
       (if mapLookup(waiting, c) == <> then 
           SpecLocked'(m, t, waiting, poss) 
        else SpecLocked'(m, t, 
                         mapUpdate(waiting, c, tail(mapLookup(waiting, c))), 
                         union(poss, {head(mapLookup(waiting, c))})))
  [] SCL::callSignalAll.m?c:ConditionID!t -> 
       (if mapLookup(waiting, c) == <> then 
           SpecLocked'(m, t, waiting, poss) 
        else SpecLocked'(m, t, mapUpdate(waiting, c, <>), 
                         union(poss, set(mapLookup(waiting, c)))))
  [] SCL::callRelease.m.t -> SpecLockedReleasing'(m, t, waiting, poss)
  [] SCL::callAcquire.m?t':diff(ThreadID, 
                                Union({values(waiting), poss, {t}})) -> 
       SpecLocked'(m, t, waiting, union(poss, {t'}))

-- t doing a wait; needs to release the lock
SpecLockedWaiting'(m, c, t, waiting, poss) =
     SCL::release.m.t -> 
       SpecUnlocked'(m, mapUpdate(waiting, c, (mapLookup(waiting, c)^<t>)), poss)
  [] SCL::callAcquire.m?t':diff(ThreadID, 
                                Union({values(waiting), poss, {t}})) ->
       SpecLockedWaiting'(m, c, t, waiting, union(poss, {t'}))

-- t releasing the lock
SpecLockedReleasing'(m, t, waiting, poss) =
     SCL::release.m.t -> SpecUnlocked'(m, waiting, poss)
  [] SCL::callAcquire.m?t':diff(ThreadID, 
                                Union({values(waiting), poss, {t}})) ->
       SpecLockedReleasing'(m, t, waiting, union(poss, {t'}))

SpecSCL' = SpecUnlocked'(SigM.S.0, init, {})  


-- Only assertion that fails is (SpecSCL') [FD= (SCLSystem)
-- this is expected as our specification does not diverge; could 
-- non-deterministically add divergences whenever a thread is waiting
assert (SpecSCL') [T= (SCLSystem) 
assert (SpecSCL') [F= (SCLSystem) 
assert (SpecSCL') [FD= (SCLSystem) 

assert (SpecSCL') [T= (SCLSystemDet) 
assert (SpecSCL') [F= (SCLSystemDet) 
assert (SpecSCL') [FD= (SCLSystemDet) 


-- Thread''(t) = SCL::callAcquire.monC.t -> SCL::acquire.monC.t -> Thread1''(t)
-- Thread1''(monC, t) = 
--      SCL::callRelease.monC.t -> SCL::release.monC.t -> Thread''(t)
--   [] SCL::callAwait.monC.t -> SCL::release.monC.t -> SCL::acquire.monC.t -> Thread1''(t)
--   [] SCL::callSignal.monC.t -> Thread1''(t)
--   [] SCL::callSignalAll.monC.t -> Thread1''(t)
 
-- SpecUnlocked''(waiting) =
--   SCL::acquire.monC?t:diff(ThreadID, set(waiting)) -> SpecLocked''(t, waiting)   

-- SpecLocked''(t, waiting) =
--   SCL::callAwait.monC.t -> SCL::release.monC.t -> SpecUnlocked''(waiting^<t>)
--   []
--   SCL::callSignal.monC.t -> (if waiting == <> then SpecLocked''(t, waiting) 
--                              else SpecLocked''(t, tail(waiting)))
--   []  
--   SCL::callSignalAll.monC.t -> (if null(waiting) then SpecLocked''(t, waiting) 
--                                else SpecLocked''(t, <>))
--   []
--   SCL::release.monC.t -> SpecUnlocked''(waiting)

-- SpecSCL'' = SpecUnlocked''(<>) [|{|SCL::acquire.monC, SCL::release.monC, SCL::callAwait.monC, SCL::callSignal.monC, SCL::callSignalAll.monC|}|] 
--             (||| t <- ThreadID @ Thread''(t))


-- Both satisfy refinement under traces, stable-failures
-- Failures-divergences fails when spurious wakeups allowed

--TODO: Add regulator?

-- assert SpecSCL [F= SpecSCL'
-- assert SpecSCL' [F= SpecSCL

-- assert SpecSCL' [F= SpecSCL''
-- assert SpecSCL'' [F= SpecSCL'

-- assert SpecSCL'' :[divergence free]
-- assert (SpecSCL'') [T= (SCLSystem) 
-- assert (SpecSCL'') [F= (SCLSystem) 
-- assert (SpecSCL'') [FD= (SCLSystem) 

-- assert (SpecSCL'') [T= (SCLSystemDet) 
-- assert (SpecSCL'') [F= (SCLSystemDet) 
-- assert (SpecSCL'') [FD= (SCLSystemDet) 



-- I think this refinement is sufficient to show correctness of a monitor:
--  - Traces shows that the spec and implementations can perform the 
--    same operations at the same time
--  - Failures show that these have the same rejections and that any 
--    thread can be signalled to wake up/acquire the monitor at any 
--    point whilst not waiting etc.

