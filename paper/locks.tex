\section{Modelling and analysing implementations of locks}
\label{sec:locks}



% \inlineScala

In this section we will analyse a number of different lock implementations. 

The primary purpose of locks is to provide \emph{mutual exclusion} between threads; that is to avoid two threads from operating concurrently on the same section of code, referred to as the \emph{critical region}. A good lock should also fulfil some \emph{liveness} requirements, essentially that something good will eventually happen. We will present a few models of locks and examine how we can model certain liveness and safety properties using CSP.

%When devising liveness requirements we assume that no thread wil hold the lock indefinitely; otherwise most reasonable liveness requirements can be invalidated by a thread that gains the lock and never releases it. \emph{Deadlock freedom} is a liveness requirement that if some thread is attempting to acquire the lock then some thread will eventually succeed in acquiring the lock, unless a thread holds the lock indefinitely. \emph{Starvation freedom} is a liveness requirement that any thread that tries to gain the lock will eventually succeed; by contrast deadlock freedom allows one thread to never obtain the lock as long as others complete an infinite number of critical sections. Other requirements/useful properties of locks will be explored later.

\subsection{External interfaces}

The most straightforward interface of a lock can be seen in Figure \ref{code:LockInterface}. This provides a |lock| function for a thread to attempt to gain the lock (blocking if some other thread currently hold the lock) and an |unlock| function for a thread to release the lock. 

\begin{figure}[H]
\begin{scala}
  trait Lock{
    /** Acquire the Lock. */
    def lock : Unit
    /** Release the Lock. */
    def unlock : Unit 
    ...
  }
\end{scala}
\caption{A Scala interface for a simple lock}
\label{code:LockInterface}
\end{figure}

\framebox{MOVE}
When a thread |t| uses a lock |l| with there are four main events of importance to model in CSP:

\begin{itemize}
  \item |callLock.l.t| : The thread calls the lock function;
  \item |lockAcquired.l.t| : The thread exits the lock function, now holding the lock;
  \item |lockReleased.l.t| : The thread has called the unlock function and the unlock function has been executed to the point where a thread can now reobtain the lock
  \item |end.t| : The thread will make no further calls to the lock; this can be used to indicate that the thread has terminated, been permanently descheduled
\end{itemize}

Throughout the paper, we will use |callX| to represent a thread calling function |X| and |end.t| to represent a thread terminating. The set of all threads is |ThreadID :: T.{0 .. NTHREADS - 1}|. We will now specify some ideal properties of locks using these channels:

\subsubsection{Mutual Exclusion}\label{mutual-exclusion}
Mutual exclusion is a safety property which states that at most one thread; i.e.~that once thread A obtains the lock, no other thread can obtain the lock until thread A unlocks. We can therefore deduce that a lock |l| with model |X| satisfies the trace refinement:  

%This specifies that at most one thread may be in its critical section at any one time; i.e.~that once thread A obtains the lock, no other thread can obtain the lock until thread A unlocks. We can therefore deduce that a lock |l| with model |X| satisfies the trace refinement:  
  
  \begin{cspm}
    Mutex = lockAcquired.l?t -> lockReleased.l.t -> Mutex
    assert Mutex [T= X \ (£$\Sigma$£ - [|lockAcquired.l, lockReleased.l|])
  \end{cspm}

\subsubsection{Deadlock Freedom}\label{deadlock-freedom}
This specifies that if some thread attempts to acquire the lock then a thread will succeed in acquiring the lock\cite{TAoMP}. 

%This does allow a CSP deadlock \framebox{Need to explain earlier} if no thread is attempting to acquire the lock, but only if the following holds: \framebox{format this}
  
  % $\forall(s,ref) \in failures(P) \, . \,\, \#(s \downarrow callLock)= \#(s \downarrow lockAcquired) \implies ref \subset \Sigma $
  
  % This can be captured by the following failures refinement on lock |l| with the set of all threads called |ThreadID|. This process can non-deterministically deadlock when no threads are attempting to obtain the lock and otherwise ensures that if a thread attempts to acquire the lock then some thread obtains the lock

  We can express this in the stable-failures model by ensuring that |lockAcquired.l| is always available to be communicated when some thread has called the lock but not yet obtained it.

  \begin{cspm}
    AcquireLock(l, ts) = 
         callLock.l?t:(diff(ThreadID, ts)) -> AcquireLock(l, union(ts, {t}))
      [] lockAcquired.l?t:ts -> AcquireLock(l, diff(ts, {t}))

    assert AcquireLock(l, {}) [F= 
        X \ (£$\Sigma$£ - {|callLock.l, lockAcquired.l|})
  \end{cspm}
  |AcquireLock| takes two parameters: |l| is the identity of the lock and |ts| is the set of threads currently which have communicated a |callLock| but haven't yet acquired the lock. In our refinement check, we will assume that no lock events have occurred prior; ie. no threads have already attempted to acquire the lock. %\framebox{Explain lack of end}
  %|AcquireLock| takes three parameters: |l| is the identity of the lock, |ts| is the set of threads currently which have communicated a |callLock| but haven't yet acquired the lock. Finally, |TS| is the set of all live threads; this is so that we can accurately restrict the threads that . 

\subsubsection{Livelock Freedom}\label{livelock-freedom}
%This specifies that the system must make actual progress; i.e.~that threads can't repeat actions indefinitely without making any progress. 
This requirement specifies that the number of internal actions on a lock must be bounded while no thread holds the lock; i.e.~threads can't indefinitely repeat actions whilst the lock is unheld. This can be captured in the failures-divergences model, using a specification process parametised over lock |l| and a failures-divergences refinement against a system that only has |lockAcquired| and |lockReleased| as visible communications.

\begin{cspm}
LiveUnlocked(l) =   lockAcquired.l?t -> LiveLocked(l)
                  |~| STOP
LiveLocked(l) =     lockReleased.l?t -> LiveUnlocked
                  |~| DIV

assert LiveUnlocked(l) [FD= X \ (£$\Sigma$£ - [|lockAcquired.l, lockReleased.l|])
\end{cspm}

This specification allows the lock to diverge only when it is held by some thread and to be divergence free otherwise. This forces the number of internal actions when the lock is not held to be finite (else it could diverge and the refinement would fail), indicating that no livelock has occured. We allow the specification to non-deterministically |STOP| when the lock is unheld; this models the effective behaviour of the lock after all threads terminate.


These are three almost essential properties of useful locks; we will consider starvation-freedom later.


\subsection{A simple lock specification} 

Figure \ref{code:LockSpec} shows a simple trace specification for a lock, where |l| is the identity of the lock and |ts| is the set of threads that can interact with the lock. 

%This specification has the required property of mutual exclusion - once a thread has performed a |lockAcquired.l.t|, no other threads can acquire the lock until after the lock has been released. It also satisfies deadlock-freedom since it can always communicate a |callLock| unless either |ts == TS| (in which case some thread can communicate a |lockAcquired| then |lockReleased|) or |TS = {}| (where all threads have 'terminated' via |exit| and hence is deadlock-free since no threads will attempt to obtain the lock). Livelock-freeness is also satisfied as all actions performed make progress towards obtaining the lock or releasing the lock once it is held. 

\begin{figure}
\begin{cspm}
LockSpec(l, ts) = SpecLock(l) [|{|lockAcquired.l, lockReleased.l|}|]
                      (||| t <- ThreadID @ SpecThread(l, t))
SpecThread(l, t) =    
     callLock.l.t -> lockAcquired.l.t -> lockReleased.l.t -> SpecThread(l, t)
  [] end.t -> STOP
SpecLock(l) = lockAcquired.l?t -> lockReleased.l.t -> SpecLock(l)
\end{cspm}
\caption{A non-starvation-free trace specification for a lock}
\label{code:LockSpec}
\end{figure}

This specification has the properties of mutual exclusion, livelock-freedom and deadlock-freedom; we have verified this by running the three assertions from \ref{mutual-exclusion}, \ref{deadlock-freedom} and \ref{livelock-freedom}. As a result, any process which failures refines\framebox{check} this specification also has these three properties. \framebox{explanation of why?}

\subsection{Test-and-Set Lock}

The Test-and-Set (TAS) lock implementation is based on using an |AtomicBoolean| called |state| to capture whether the lock is currently held, with |true| indicating that some thread holds the lock and |false| otherwise. The |AtomicBoolean|, has atomic |get| and |set| operations to read and write values respectively. It also has a |getAndSet| operation which atomically sets the value of the Boolean and returns the old value. The Scala code can be seen in Listing \ref{fig:TASScala}. |state| being false is equivalent to the lock being unlocked; a communication of |getAndSet(true)| with previous value |false| indicates that that thread has now obtained the lock. % that no thread previously held the lock; the thread can then release the lock by setting the value back to |false|.%When a thread attempts to obtain the lock, it performs a |state.getAndSet(true)|; a |getAndSet(true)| that returns |false| can be treated as having gained the lock, whereas a |true| indicates that some other thread already holds the lock. To release the lock a |set(false)| is done to mark the lock as available to other threads.

\begin{figure}
  \begin{scala}
  import java.util.concurrent.atomic.AtomicBoolean

  /** A lock based upon the test-and-set operation 
    * Based on Herlihy & Shavit, Chapter 7. */
  class TASLock extends Lock{
    /** The state of the lock: true represents locked */
    private val state = new AtomicBoolean(false)

    /** Acquire the Lock */ 
    def lock = while(state.getAndSet(true)){ }

    /** Release the Lock */
    def unlock = state.set(false)
  }
  \end{scala}
  \caption{Test-and-set lock from \cite{CADS} \label{fig:TASScala}}
\end{figure}

\inlineCSP

In order to model the TAS lock, we first need a process that acts as an |AtomicBoolean| to model the |state| variable. Figure \ref{csp:Variable} introduces a process |AtomicVar| than takes an initial value, and channels |get, set : ThreadID.T| and |getAndSet : ThreadID.T.T| for some arbitrary type |T|.

\begin{figure}
  \begin{cspm}
AtomicVar(value, get, set, gAS) = 
     get?_!value -> AtomicVar(value, get, set, gAS)
  [] set?_?value' -> AtomicVar(value', get, set, gAS)
  [] gAS?_!value?value' -> AtomicVar(value', get, set, gAS) 
  \end{cspm}
  \caption{A process encapsulating an Atomic variable with get, set and getAndSet operations}
  \label{csp:Variable}
\end{figure}

We therefore represent the |state| variable from the Scala implementation by the following CSP:
\begin{cspm}
  channel get, set: ThreadID . Bool
  channel getAndSet: ThreadID . Bool . Bool
  State = Var(false, get, set, getAndSet)
  InternalChannels = {|get, set, getAndSet|}
\end{cspm}
A communication on any of the channels is equivalent to a thread calling the corresponding operation in Scala. We use |false| to indicate that no thread holds the lock initially.

We next model the operations of the lock itself. Both operations are trivial to convert, and we can linearize |Lock(t)| when the communication |getAndSet.t.False.True| occurs, indicating that |t| has obtained the lock.

\begin{cspm}
  Unlock(t) = setState.t!False -> SKIP -- def unlock = state.set(false)

  Lock(t) = getAndSet.t?v!True -> if v == False then SKIP 
                                    else Lock(t)
\end{cspm}

% The |Lock| procedure is also trivial, with the thread just communicating over |getAndSet|. The procedure terminates once the |getAndSet| communicates that the original value of the |state|variable was false; a |getAndSet.t.False.True| event in a trace can be linearized as the point at which the thread |t| obtains the lock.


We model the threads that are attempting to obtain the lock by a process |Thread(x)|, where |x| is the identity of the thead. Each thread can non-deterministically chooses to either terminate or obtain the lock, release the lock and repeat. %; we use external choice here so that we can regulate the  behaviour of the threads when analysing the lock's properties. 
Here we use |L.0| as the identity of the lock.

\begin{cspm}
  Thread(t) =   £$\,$£callLock.L.0.t -> Lock(t); Unlock(t); Thread(t)
              [] end.t -> SKIP
\end{cspm}

Finally, we construct the lock from its components. We first synchronise all the threads over the |get|, |set| and |getAndSet| channels with the |State| process. Since |getAndSet.t.False.True| and |setState.t.False| are the linearisation points of thread |t| obtaining and releasing the lock, we can rename these communications to |lockAcquired.L.0.t| and |lockReleased.L.0.t| respectively to produce |ActualSystemR|. Finally, to obtain a system that only visibly communicates the four previously identified events, we hide the internal channels of the lock to produce |ActualSystemRExtDiv|.

\framebox{Diagram?}

\begin{cspm}
  -- All initially do not hold the lock
  AllThreads = ||| t : ThreadID @ Thread(t)
  -- Allow all threads to peform actions on the state variable
  ActualSystem = (AllThreads [|InternalChannels|] State)
  -- Rename lock acquisition and releasing and hide internal events
  ActualSystemR = ActualSystem 
                    [[getAndSet.t.False.True <- lockAcquired.L.0.t, 
                     £$\!\!\:\:\!\!\:\!\:$£set.t.False            £$\!\!\:\:\!\!\:\!\;$£<- lockReleased.L.0.t  | t <- ThreadID]]
  ActualSystemRExtDiv = ActualSystemR \ InternalChannels
\end{cspm}

\subsubsection{Analysis}

We firstly examine whether this model fulfils the aforementioned properties. The mutual exclusion, deadlock freedom and livelock-freedom tests from sections \ref{mutual-exclusion}, \ref{deadlock-freedom} and \ref{livelock-freedom} respectively pass. The model also does not diverge before it is first held; these are all expected results\framebox{Why?}. The TAS lock is also equivalent under traces with the earlier lock specification. However, the model can diverge whenever the lock is held. This occurs when a thread (or threads) attempting to obtain the lock a thread attempting to obtain the lock perform an infinite number of |getAndSet| operations; an example trace of this behaviour where |T.0| obtains the lock |l| follows
\begin{cspm}
  £$\langle$£callLock.l.T.0, callLock.l.T.1, getAndSet.T.0.False.True£$\rangle$£^
    £$\langle$£getAndSet.T.1.True.True£$\rangle^\omega$£
\end{cspm}
  
This behaviour is expected; thread |T.1| is trying to obtain the lock and is being blocked by |T.0| which holds the lock. This behaviour is, however, problematic for low-level performance. Any |getAndSet| operation causes a broadcast on the shared memory bus between the processors, delaying all processors \framebox{Ref}. This also forces each thread to invalidate the value of |state| from the caches, regardless of whether the value has actually been changed. Since the above trace never results in thread |T.1| successfully setting |state|, it is preferrable to limit the number of |getAndSet| operations without unneccessarily delaying a thread from obtaining the lock. As a result, we use less costly |get| operations in order to limit the usage of |getAndSet| operations; these |getAndSet| operations are instead limited to situations where they are likely to obtain the lock. Since |get| does not change the underlying value of a variable, the read will result in at most one cache-miss per |set|/|getAndSet| on |state|; this is a marked improvement\framebox{Level of detail regarding memory buses, performance, caching etc} 


\subsection{Test-and-Test-and-Set Lock}

\begin{figure}
  %\begin{Scala}
  \begin{scala}
    class TTASLock extends Lock{ 
      £\dots£
      /** Acquire the lock */
      def lock = 
        do{
          while(state.get()){ } // spin until state = false
        } while(state.getAndSet(true)) // if state = true, retry
      £\dots£
    }
  \end{scala}
  %\end{Scala}
  \caption{Test-and-test-and-set lock from \cite{CADS}  \label{scala:TTAS}}
\end{figure}

The Test-and-Test-and-Set (TTAS) lock makes use of this improvement, whilst otherwise remaining similar to the TAS lock. The sole change is to the |lock| function, as can be seen in Figure \ref{scala:TTAS}, which we then specify in our CSP model as the following: 
\begin{cspm}
  Lock(t) =  getState.t?s -> if s = True then Lock(t)
                             else gASState.t?v!True -> if v = False then SKIP
                             else delay!t -> Lock(t)
\end{cspm}
The TTAS lock can still produce traces with threads performing an unbound number of consecutive operations, however these are now |get| operations instead of |getAndSet| operations. %Whereas the TAS lock can have an unbounded number of |getAndSet| operations for each time the lock is obtained, the 
The TTAS lock has performs at most one |getAndSet| operation per thread when the lock becomes available. This is the case when each thread's last communication was |get.t.False|, indicating that the lock is available and hence leading to a |getAndSet| communication to attempt to gain the lock.

We now have a linear bound on the number of unsuccessful getAndSet operations, resulting in much more efficient usage of caching and shared memory. This has been verified by synchronising with a regulator process which outputs on an error channel if |n| |getAndSet|s occur in one locking cycle; this regulator acts as a watchdog. Since the trace refinement is satisfied, we have that no |error| event has been communicated and hence at most |n| getAndSets can occur every time the lock is released. 

\begin{cspm}
channel error
Reg(x) =    gASState?_ -> if (x < card(ThreadID)) then Reg(x+1)
                          else error -> STOP
         [] lockReleased?_ -> Reg(0)

assert LockSpec(L.0, {}, ThreadID) 
         [T= ActualSystemR [|{|gASState, lockReleased|}|] Reg(0)
\end{cspm}

\subsection{Peterson lock}

The Peterson lock is 



% \subsection{Tree lock}

% \framebox{Might be worth introducing Peterson lock for starvation freedom both earlier and here?}

% Suppose we have an implementation of a lock that works for upto n threads and now wanted to extend this to work with more threads trying to obtain a single lock. One approach to solving this problem is to arrange a number of the n thread locks into a tree structure. The threads are assigned a leaf node and, once they have obtained that lock, they progress up the tree obtaining the next lock and so on. Once the thread reaches the root of the tree and has obtained the 'root lock' and hence holds the lock; to unlock, the thread unlocks the root lock and progressively unlocks all the locks it held until it is back at the leaf lock. To consider a simple case where n = 2 and NThreads = 8 we have the following structure: \framebox{Draw properly}

% \begin{figure}
% \begin{verbatim}
%                                   L.0
%                                 /     \                    
%                                /       \
%                               /         \
%                              /           \
%                            L.1           L.2
%                           /  \           /  \
%                          /    \         /    \
%                         /      \       /      \
%                        L.3     L.4    L.5     L.6
%                       /  |     / |    |  \    |  \
%                      /   |    /  |    |   \   |   \
%                  T.3.1   | T.4.1 |    | T.5.2 |   T.6.2
%                       T.3.2   T.4.2    T.5.1   T.6.1
% \end{verbatim}
% \caption{An example of the tree lock with 2 threads per lock and 8 threads \label{fig:Tree}}
% \end{figure}

% Here, for T.5.1 to obtain the root lock L.0, it must first obtain L.5 then L.2 then it can attempt to lock L.0. If it holds L.0 then all of the other 7 threads can't enter their critical section. Once T.5.1 wants to release the lock it unlocks L.0, then unlocks L.2 then finally unlocks L.5. T.5.1 can now either terminate or try to reobtain the root lock.

% \subsubsection{Modelling}

% We model the tree structure so that the structure of the tree is independent from the implementation of the individual locks; this will allow us to examine how different the different properties of the locks affect the overall structure.

% For convenience, we shall call the threads |T.{y}.{z}| where y is the leaf lock that the thread will first try and obtain and z is just an index over the threads starting at that leaf lock. Since the thread should be agnostic to the implementation of the lock, the thread initially either exits or calls |LockTree| to try and obtain the lock. Once the thread has obtained the lock, it then releases it by a call to |UnlockTree|. Both |LockTree| and |UnlockTree| are recursively defined, traversing their way up and down the tree respectively before terminating once they have locked the root lock or unlocked a leaf lock respectively. 
% |nextUnlock(x, y)| is used as a helper function to generate the next lock to release 

% \begin{cspm}
%   nextUnlock(x, y) = if (y / 2 > x) then nextUnlock(x, y/2) else L.y 

%   LockTree(t, L.0) = SKIP
%   LockTree(T.y.z, L.x) = Lock(T.y.z, L.x); LockTree(T.x.y, L.((x-1)/2))

%   UnlockTree(T.y.z, L.x) = if (x == y) then Unlock(T.y.z, L.x); SKIP
%                            else Unlock(T.y.z, L.y); 
%                                 UnlockTree(T.y.z, nextUnlock(x, y))

%   Thread(T.y.z) = callLock.L.y.T.y.z -> LockTree(T.y.z, L.y); 
%                                           UnlockTree(T.y.z, L.0); 
%                                           Thread(T.y.z)
%                  [] end.T.y.z -> SKIP
% \end{cspm}

% We can use the |lockAcquired| and |lockReleased| events of the root |L.0| lock as the points where a given thread obtains and releases the lock and the |callLock| events of the leaf nodes to represent when a thread tries to access the lock. To check that this lock fulfils the required properties we will hide all internal locking events; we do not care how the lock functions internally as long as it follows the required specifications. We will also rename the the three above events to appear to occur on the lock L.0. The system is therefore constructed as follows:

% \begin{cspm}
%   -- Initialise threads to not hold their locks
%   AllThreads = ||| (T.y.z) : ThreadID @ Thread(T.y.z)
%   -- Initialise all the locks
%   AllLocks = ||| (L.x) : LockID @ LockSystem(L.x)
%   -- Sychronise the threads with all the locks
%   TreeInternal = (AllThreads [|LockEvents|] AllLocks)
%   -- Hide unwanted lock events from internal locks
%   TreeHidden = TreeInternal \ Union(diff({|lockAcquired|}, {|lockAcquired.L.0|}), 
%                                      diff({|unlockedLock|}, {|unlockedLock.L.0|}),
%                                      diff({|callLock|}, 
%                                             {callLock.L.y.T.y.z | T.y.z <- ThreadID}))
%   -- Rename linearization points so all refer to L.0
%   TreeInternalRenamed = TreeHidden [[callLock.L.x.t <- callLock.L.0.t]]
% \end{cspm}

% \framebox{Add analysis of behaviours with different node locks etc}


\subsubsection{Starvation Freedom} \label{starvation-freedom}

Starvation freedom is a liveness property that states that, under the assumption that no thread holds the lock indefinitely, every thread that attempts to acquire the lock eventually succeeds \cite{TAoMP}. It requires that any thread attempting to gain the lock must can only be bypassed by other threads a finite number of times.

One common approach to checking infinite properties in CSP is to hide some (in this case internal) channels and then check that the model does not diverge. This approach does not work here: consider a starvation-free lock which uses busy waiting (repeatedly testing if the lock is available). We have that hiding the internal communications results in a divergence, however the lock is starvation-free. An example of such a lock is the Peterson lock \framebox{link to model}.

Roscoe and Gibson-Robinson showed that every infinite traces property that can be captured by CSP refinement can also be captured by a finite-traces refinement check when combined with the satisfaction of a deterministic B{\"u}chi automaton \cite{RoscoeBuchi}. A B{\"u}chi automaton, as explained by \framebox{REF}, is an automaton that takes infinite inputs and accepts an input if an accepting state is visited infinitely often \framebox{Improve}.\framebox{need to go over the above} However, we can show that no deterministic B{\"u}chi automaton can capture starvation freedom. 

% The automaton should be satisifed by any trace where some thread obtains the lock; this requires that the BA has some accepting state that can be visited an infinite amount of times when some thread |t| holds the lock. Since BA have a finite number of states, that state must be reachable in a finite sequence of steps. As a result, the BA must be satisfied by some thread obtaining the lock, reaching an accepting state in the BA, releasing the lock and repeating that same process. This, however, would accept non-starvation free locks.

% We need at least one accepting state where some thread holds the lock. Otherwise the automaton would reject a starvation free lock with some trace where a thread obtains the lock and never releases it. At least one of these accepting states must be visitable an infinite number of times.

% We can't have an accepting state where some thread holds the lock. Consider a lock that is not starvation free and suppose one thread (wlog.~|T.0|) calls the lock. Some other thread (wlog.~|T.2|) calls the lock, acquires it and releases it without the original caller making any progres

% We have that the BA should be satisfied by a run where some thread immediately obtains a lock and never releases it. We can therefore conclude that any BA must have at least one accepting state where some thread holds the lock and that some subset of the accepting states can be reached infinitely often.

% Now suppose we have a 2-threaded lock which is not starvation free. 

% Suppose we have a 2-threaded lock which is starvation free. The BA should be satisfied by a run where thread |T.1| proceeds and is permanently descheduled before obtaining the lock 

We will show by contradiction that no such deterministic automaton $B$ can capture starvation freedom. Let us without loss of generality consider 2-threaded locks. 

By the definition of starvation freedom, the automaton should be satisfied if |T.0| acquires and never releases the lock and |T.1| attempts to acquire the lock. The automaton therefore must have some accepting state which is visited an infinite number of times when |T.0| holds the lock and |T.1| attempts to acquire it; we will call this state $q_{a}$.

%the repeated actions of the threads cause (a subset of) the accepting states to be visited infinitely often.

% Now suppose that |T.0| again holds the lock and |T.1| is attempting to acquire the lock. By the above, we have that there is some reachable accepting state in the automaton where this is the case; we run until we reach this state and then |T.0| releases the lock. |T.0| then reobtains the lock successfully - we have that the automaton can not block this behviour, else it excludes the starvation-free lock where |T.1| can only obtain the lock when |T.0| has acquired and released the lock an even number of times. Again, since |T.0| could hold the lock indefinitely, we have that some accepting state must be reachable where |T.0| holds the lock and |T.1| is attempting to acquire the lock. Once we reach this state, |T.0| can release the lock and repeat this cycle. Since this cycle can be repeated indefinitely, we have that this is required to be an accepting run if the lock is starvation free. However, we have that the run is accepted even if the lock is not starvation-free; an example being the TAS lock from before as the only communication |T.1| makes whilst trying to obtain the lock unsuccessfully is via same |getAndSet.l.T.1.true.true| communication). 

% We therefore have that we have shown by construction that a general, deterministic B{\"u}chi automaton for starvation-freeness cannot exist.

Now we consider the TAS lock from before. This is clearly not starvation free as the first thread to communicate on |getAndSet| once the lock becomes available will acquire it; this allows some thread to infinitely bypass some other waiting thread. Consider an execution where |T.0| repeatedly acquires and releases the lock, bypassing |T.1| which is repeatedly attempting and failing to obtain the lock. This execution, however, passes through the state $q_{a}$ of $B$ every time |T.0| acquires and later releases the lock. This can occur an infinite number of times, resulting in $B$ accepting this execution. This is a contradiction as this execution is clearly not starvation free as |T.1| never obtains the lock, however it still satisfies $B$.


% Now we consider the TAS lock from before. This is clearly not starvation free as the first thread to communicate on |getAndSet| once the lock becomes available will acquire it. As a result |T.0| can bypass |T.1| an infinite number of times, hence the TAS lock is not starvation free. We have from the above that there must exist some accepting state in the automaton which is reachable when |T.0| holds the lock and |T.1| is attempting to obtain the lock. Since |T.1| only has one available state when |T.0| holds the lock (communicating a |getAndSet.L.0.T.1.false.false|), we have that this accepting state must be reachable whenever |T.0| bypasses |T.1|. As a result, we have that |T.0| can obtain the lock an infinite number of times, and each of these bypasses can result in a visit to an accepting state of the automaton. We therefore have that the B{\"u}chi automaton accepts this run despite the both the run and the TAS lock not being starvation-free. This is a contradiction and hence we have that no such deterministic automaton can exist.

\framebox{Improve}We hence have that no deterministic B{\"u}chi automaton can accurately capture starvation freedom and hence we cannot test directly for starvation-freedom through a standard FDR refinement check.

\subsection{First-come-first-served}

We can instead consider capturing the stronger propety of first-come-first-served. Locks that satisfy this property can be split into a \emph{doorway} section of a bounded number of steps and a folowing \emph{waiting} section of a potentially unbounded number of execution steps. This property states that once thread |X| has completed the doorway section of the lock it cannot be overtaken by a thread |Y| that has not yet started its doorway section; i.e.~ |X| will acquire the lock before |Y| acquires the lock. This implies starvation-freedom as once |X| has completed its doorway section, it can only be bypassed by threads who have started their doorway section prior to |X|.

\begin{cspm}
  FCFSNotStarted(l, t, s1, s3) = 
     end.t -> FCFSTerminated(l, t)
  [] callLock.l.t -> FCFSStarted(l, t, s1, s3)
  [] doorwayComplete.l?t':diff(ThreadID, union({t}, union(s1, s3))) -> FCFSNotStarted(l, t, union(s1, {t'}), s3)
  [] lockAcquired.l?t':diff(union(s1, s3), {t}) -> FCFSNotStarted(l, t, diff(s1, {t'}), s3)


FCFSStarted(l, t, s1, s3) = 
     doorwayComplete.l.t -> FCFSCompleted(l, t, s1, s3)
  [] doorwayComplete.l?t':diff(ThreadID, union({t}, union(s1, s3))) -> FCFSStarted(l, t, s1, union(s3, {t'}))
  [] lockAcquired.l?t':diff(union(s1, s3), {t}) -> FCFSStarted(l, t, diff(s1, {t'}), diff(s3, {t'}))

FCFSCompleted(l, t, s1, s3) = 
     empty(s1) & lockAcquired.l.t -> FCFSNotStarted(l, t, s3, {})
  [] doorwayComplete.l?t':diff(ThreadID, union({t}, union(s1, s3))) -> FCFSCompleted(l, t, s1, union(s3, {t'}))
  [] lockAcquired.l?t':diff(union(s1, s3), {t}) -> FCFSCompleted(l, t, diff(s1, {t'}), diff(s3, {t'}))

FCFSTerminated(l, t) = 
     doorwayComplete.l?t':diff(ThreadID, {t}) -> FCFSTerminated(l, t)
  [] lockAcquired.l?t':diff(ThreadID, {t}) -> FCFSTerminated(l, t)
\end{cspm}

\begin{cspm}
FCFSCheck(l) = 
  || t <- ThreadID @ [union({callLock.l.t, end.t}, {|doorwayComplete.l, lockAcquired.l|})]
        FCFSNotStarted(l, t, {}, {})

assert FCFSCheck(L.0) [T= FCFSActualSystemRExtDiv \ {|lockReleased|}
\end{cspm}

