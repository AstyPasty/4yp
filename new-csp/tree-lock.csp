-- A lock based upon the test-and-set operation with fixed-time backoff.
--  * Based on Herlihy & Shavit, Section 7.4. 
--  * @param delay the time in nanoseconds to delay when conflict detected.

include "variable.csp"
include "lock-spec.csp"

NTHREADS_SPIN = 4 
NTHREADS_SPEC = 8
NLOCKS_SPIN = NTHREADS_SPIN - 1
NLOCKS_SPEC = NTHREADS_SPEC - 1

datatype LockID = L.(union({0..NLOCKS_SPIN-1}, {0..NLOCKS_SPEC-1}))
subtype Lock_SPIN = L.{0..NLOCKS_SPIN-1}
subtype Lock_SPEC = L.{0..NLOCKS_SPEC-1}
datatype ThreadID = T.(union({0..NLOCKS_SPIN-1}, {0..NLOCKS_SPEC-1})).{1..2}
subtype Thread_SPIN = T.{(NLOCKS_SPIN-1)/2..NLOCKS_SPIN-1}.{1..2}
subtype Thread_SPEC = T.{(NLOCKS_SPEC-1)/2..NLOCKS_SPEC-1}.{1..2}


channel delay: ThreadID.LockID
channel getAndSet: LockID.ThreadID.Bool.Bool
channel get: LockID.ThreadID.Bool
channel set: LockID.ThreadID.Bool
channel parent: LockID.LockID
channel child: LockID.LockID
channel notStarved: ThreadID

LocksSpin = Array(Lock_SPIN, false, get, set, getAndSet) 

InternalChannels = {|get, set, getAndSet, delay|}
LockEvents = {|callLock, lockObtained, lockNotObtained, lockUnlocked|}--, lockUnlocked|}
LockEventsC = {callLock, lockObtained, lockNotObtained, lockUnlocked}--, lockUnlocked}

TLockParent(t, L.0) = TUnlock(t, L.0)
TLockParent(t, L.x) = TNotHolding(t, L.((x-1)/2))

TUnlockChild(T.x.y, L.z) = if(z == 0) then TUnlock(T.x.y, L.x) else TNotHolding(T.x.y, L.x)
                              --   else if (z==1 and NTHREADS > 4) then if ((x < 9 and NTHREADS == 16) or x ==3) then TUnlock(T.x.y, L.3) else if (NTHREADS == 8) then TUnlock(T.x.y, L.4) else TNotHolding(T.x.y, L.x)
                              --   else if (z==2 and NTHREADS > 4) then if ((x < 13 and NTHREADS == 16) or x == 5) then TUnlock(T.x.y, L.5) else if (NTHREADS == 8) then TUnlock(T.x.y, L.6) else TNotHolding(T.x.y, L.x)
                              --   else TNotHolding(T.x.y, L.x)
                              --else if n == 8 then

                        --else if (z==1 and NTHREADS >= 4) then if (x < 9 and NTHREADS == 16 or x ==3) then TUnlock(T.x.y, L.3) else if (NTHREADS == 4) then TUnlock(T.x.y, L.4) else TNotHolding(T.x.y, L.x)
                        --else if (z==2 and NTHREADS >= 4) then if (x < 13 and NTHREADS == 16 or x == 5) then TUnlock(T.x.y, L.5) else if (NTHREADS == 6) then TUnlock(T.x.y, L.6) else TNotHolding(T.x.y, L.x)
                        --else if (z < 7 and NTHREADS >= 8) then TUnlock(T.x.y, L.x)
                        --else TNotHolding(T.x.y, L.x)

--((NLOCKS-1)/2 > y) then Unlock(T.x, L.) 

--if x < 3 then Unlock(T.x, L.1) else Unlock(T.x, L.2)


TLock :: (ThreadID, LockID) -> Proc
TLock(t, l) = get.l.t?c -> if c == True then TLock(t, l) -- while(state.get()){ }
           else getAndSet.l.t?v!True -> if v == False then THolding(t, l) -- if(! state.getAndSet(true)) done = true
           else delay.t.l -> TLock(t, l)

TUnlock :: (ThreadID, LockID) -> Proc
TUnlock(t, l) = set.l.t!False -> TUnlockChild(t, l) -- def unlock = state.set(false)

TTryLock :: (ThreadID, LockID) -> Proc
TTryLock(t, l) = get.l.t?s -> if s == True then TNotHolding(t, l) 
                                   else getAndSet.l.t?v!True -> if v == False then THolding(t, l) else lockNotObtained.l.t -> TNotHolding(t, l)  --!state.get && !state.getAndSet(true)

THolding(t, l) = TLockParent(t, l)

TNotHolding(t, l) = callLock.l.t -> TLock(t, l)--(TTryLock(t, l) |~| TLock(t, l))

-- LockSpec :: (LockID, {ThreadID}) -> Proc
-- LockSpec(l, ts) = callLock?t:(diff(Thread_SPEC, ts))!l -> LockSpec(l, union(ts, {t}))
--                       [] lockObtained?t:ts!l -> LockSpecObtained(t, l, ts)
-- LockSpecObtained(t, l, ts) = callLock?t2:(diff(Thread_SPEC, ts))!l -> LockSpecObtained(t, l, union(ts, {t2}))
--                                [] lockUnlocked.t.l -> LockSpec(l, diff(ts, {t}))



-- TreeSystemSpin
AllThreads = ||| (T.x.y) : Thread_SPIN @ TNotHolding(T.x.y, (L.x))
TreeSystemSpinInt = (AllThreads [|InternalChannels|] LocksSpin)
TreeSystemSpinLockEvents = TreeSystemSpinInt [[getAndSet.l.t.False.True <- lockObtained.l.t, set.l.t.False <- lockUnlocked.l.t | t <- ThreadID, l <- Lock_SPIN]] 
TreeSystemSpinExtDiv = TreeSystemSpinLockEvents \ InternalChannels
NoDiv = get?l?t!True -> STOP [] getAndSet?l?t!True!True -> STOP
TreeSystemSpinNoDiv = (TreeSystemSpinLockEvents [|{get.l.t.True, getAndSet.l.t.True.True | t<- Thread_SPIN, l <- LockID}|] NoDiv) \ InternalChannels

-- Obvious
assert TreeSystemSpinInt :[divergence free]
assert TreeSystemSpinInt :[deadlock free]
assert TreeSystemSpinExtDiv :[divergence free] -- Should fail
assert TreeSystemSpinNoDiv :[divergence free]

assert TreeSystemSpinExtDiv [T= TreeSystemSpinNoDiv
assert TreeSystemSpinNoDiv [T= TreeSystemSpinExtDiv

-- Doesn't tell us anything
-- CheckLockObtainable = [] t: Thread_SPIN, l:Lock_SPIN @ getAndSet.L.0.t.False.True -> STOP
--                       [] get.l.t.True -> STOP
-- --                      [] delay.t.l -> STOP
--                       [] get.l.t.False -> CheckLockObtainable
--                       [] set?_ -> CheckLockObtainable
--                       [] getAndSet.L.0.t.True?_ -> CheckLockObtainable
--                       [] getAndSet.L.1.t?_ -> CheckLockObtainable
--                       [] getAndSet.L.2.t?_ -> CheckLockObtainable
-- assert (CheckLockObtainable [|{|getAndSet, get, set|}|] TreeSystemSpin) \ union({|getAndSet, get, set|}, LockEvents) :[divergence free]


CountFailedTAS(n,orig) =  if n > 2 * NLOCKS_SPIN - 1 or n < 0 then DIV
                     else  
                      [] t: Thread_SPIN, l:Lock_SPIN @ getAndSet.l.t.True.True -> CountFailedTAS(n+1, orig)
                      [] set.L.0.t.False -> CountFailedTAS(orig, orig)
                      [] set?l:diff(Lock_SPIN, {L.0})?_ -> CountFailedTAS(n, orig)
                      [] getAndSet.l.t.False?_ -> CountFailedTAS(n, orig)
                      [] getAndSet.l.t.True.False -> CountFailedTAS(n, orig)
assert (CountFailedTAS(0, 0) [|{|getAndSet, set|}|] TreeSystemSpinNoDiv)  :[divergence free]
assert (CountFailedTAS(1, 1) [|{|getAndSet, set|}|] TreeSystemSpinNoDiv)  :[divergence free]
assert (CountFailedTAS(0, 1) [|{|getAndSet, set|}|] TreeSystemSpinNoDiv)  :[divergence free]
assert (CountFailedTAS(1, 0) [|{|getAndSet, set|}|] TreeSystemSpinNoDiv)  :[divergence free]

-- CheckAlwaysAvailable and TreeSystemSpinExtDiv (hiding all other events) are equivalent under traces
-- Root lock never becomes unavailable and ownership of the root lock is mutually exclusive
CheckAlwaysAvailable = lockObtained.L.0?t:Thread_SPIN -> lockUnlocked.L.0.t -> CheckAlwaysAvailable
assert (CheckAlwaysAvailable [|{lockObtained.L.0.t, lockUnlocked.L.0.t| t <- Thread_SPIN}|] TreeSystemSpinExtDiv) \ diff(LockEvents, {lockObtained.L.0.t, lockUnlocked.L.0.t | t <- Thread_SPIN}) [T= CheckAlwaysAvailable
assert CheckAlwaysAvailable [T= (CheckAlwaysAvailable [|{lockObtained.L.0.t, lockUnlocked.L.0.t| t <- Thread_SPIN}|] TreeSystemSpinExtDiv) \ diff(LockEvents, {lockObtained.L.0.t, lockUnlocked.L.0.t | t <- Thread_SPIN}) 
assert CheckAlwaysAvailable [|{lockObtained.L.0.t, lockUnlocked.L.0.t| t <- Thread_SPIN}|] TreeSystemSpinNoDiv \ union({lockObtained.L.0.t | t <- Thread_SPIN}, {lockUnlocked.L.0.t | t <- Thread_SPIN}) :[divergence free]



-- Check no divergence before the lock is first held
CheckNoDiv = [] t: Thread_SPIN, l : Lock_SPIN @ getAndSet.l.t.False.True -> STOP
             [] get.l.t?_ -> CheckNoDiv
             [] set.l.t?_ -> CheckNoDiv
             --[] t: Thread_SPIN @ getAndSet.l.t.True.Tr
assert (TreeSystemSpinInt [|{|getAndSet, get, set|}|] CheckNoDiv) \ {|getAndSet, set, get|} :[divergence free]



EvenSimplerLock :: (LockID) -> Proc
EvenSimplerLock(l) = callLock.l?t -> lockObtained.l.t -> lockUnlocked.l.t -> EvenSimplerLock(l)

SimpleSystemL(t, L.x, ls) = callLock.L.x.t -> lockObtained.L.x.t -> if x == 0 then SimpleSystemU(t, L.0, ls) else SimpleSystemL(t, L.((x-1)/2), <x>^ls)
SimpleSystemU(T.y.z, L.x, <>) = lockUnlocked.L.x.T.y.z -> SimpleSystemL(T.y.z, L.x, <>)
SimpleSystemU(T.y.z, L.x, <l>^ls) = lockUnlocked.L.x.T.y.z -> SimpleSystemU(T.y.z, L.l, ls)

Simple = ||| (T.x.y) : Thread_SPEC @ SimpleSystemL(T.x.y, L.x, <>)
Locks = ||| l : Lock_SPEC @ LockSpec(l, {}, Thread_SPEC)
SimpleSystem = Simple [|LockEvents|] Locks

-- Check no divergence (since locks can't be released until thread holds root)
assert SimpleSystem :[divergence free]

-- Passes iff NTHREADS_SPIN == NTHREADS_SPEC; also shows trace equality either TreeSystemSpinNoDiv
assert SimpleSystem [T= TreeSystemSpinExtDiv
assert TreeSystemSpinExtDiv [T= SimpleSystem



-- Checks that root lock is always accessible
rootAccess = lockObtained.L.0?t:Thread_SPEC -> rootAccess
assert (SimpleSystem \ diff(LockEvents, {lockObtained.L.0.t | t <- Thread_SPEC})) [T= rootAccess

assert SimpleSystem \ diff({|lockUnlocked, callLock, lockObtained|}, {lockObtained.L.0.t | t <- Thread_SPEC}) [T= rootAccess


-- Check that no thread is ever starved of the root lock
-- Test should fail since underlying lock implementation is not starvation free
SimpleStarvationFreedom(T.x.y) = lockObtained.L.0.T?a:{(NLOCKS_SPEC-1)/2..NLOCKS_SPEC-1}?b -> if a == x and b == y and y == 1 then notStarved!T.a.b -> SimpleStarvationFreedom(T.x.2)
                                                           else if a == x and b == y and x == (NLOCKS_SPEC-1) and y == 2 then notStarved!T.a.b -> SimpleStarvationFreedom(T.(NLOCKS_SPEC-1)/2.1)
                                                           else if a == x and b == y then notStarved!T.a.b -> SimpleStarvationFreedom(T.x+1.1) 
                                                           else SimpleStarvationFreedom(T.x.y)
assert SimpleStarvationFreedom(T.(NLOCKS_SPEC-1)/2.1) [|{lockObtained.L.0.t| t<-Thread_SPEC}|] SimpleSystem \ LockEvents :[divergence free]--diff(LockEvents, {lockObtainedt.L.0| t<-Thread_SPEC}) :[divergence free]

-- Count no. lock acquisitions per root acquisition
lockAcquisitions(n) = if 0 <= n and n <= NLOCKS_SPEC then (lockUnlocked?t.l -> lockAcquisitions(n-1)
                      [] lockObtained?t.l -> lockAcquisitions(n+1))
                      else DIV
assert lockAcquisitions(0) [|{|lockObtained, lockUnlocked|}|] SimpleSystem :[divergence free]


