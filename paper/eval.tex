In this paper, we have examined a range of concurrency primitives offered by the Java Virtual Machine, Scala Concurrency Library module and a range of different lock designs. We have examined and proved the correctness of each of these whilst also proving complexity results and examining other properties. There are, however, some limitations to our work. 

Firstly, by the nature of model checking, we are only able to model a limited number of threads with restrictions on other parameters too. Though model checking with larger numbers of threads is technially possible, the exponential blow up in the number of states renders it infeasible.
If a model is correct for small numbers of threads, we have significantly more confidence in the model remaining correct for larger numbers of threads. Taking the SCL monitor which has been proven correct for 6 threads and 2 conditions, since our model for the SCL monitor has been proven to be correct for 6 threads, any bug would require some interaction that requires at least 7 threads or 3 conditions.

We have also only considered a number of specific concurrency primitives. Though our approach can be extended to many other primitives, this still requires work during development to verify the correctness of these. An automated translation system from normal code to CSP would aid in this, however any general translator would suffer from additional complexity blow up due to a lack of insight. An example of this can be seen in the SCL Monitor model, where a more natural implementation of the queue lead to state spacea $n!$ times larger than a model with additional insight. Implementing an automated translator, either na\"{\i}ve or optimised, is beyond the scope of the project and therefore left as further work. 