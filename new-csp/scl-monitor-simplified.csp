module SCLMonitor


-- Including lock-support, but not as a module as multiple levels of module 
-- instances are not allowed
include "lock-support.csp"

-- Convention is monitor, condition, calling thread, target thread, 
-- has target been marked as ready
datatype Node = N.ThreadID

channel enqueue, dequeue: MonitorID.ConditionID.ThreadID.Node.ThreadID
channel setReady: Node.ThreadID.ThreadID
channel isReady: Node.ThreadID.ThreadID.Bool
channel initialise: Node.ThreadID
channel isEmpty: MonitorID.ConditionID.ThreadID
channel await, signalAll: MonitorID.ConditionID.ThreadID


Signal1(mon, cnd, t) = 
     isEmpty.mon.cnd.t -> SKIP
  [] dequeue.mon.cnd.t?n.t2 -> isReady.n.t2.t?b ->
      if b then Signal1(mon, cnd, t)
      else setReady.n.t2.t -> Unpark(mon, t, t2); SKIP

SignalAll1(mon, cnd, t) =
     isEmpty.mon.cnd.t -> SKIP
  [] dequeue.mon.cnd.t?n.t2  -> setReady.n.t2.t -> 
          Unpark(mon, t, t2); SignalAll1(mon, cnd, t)

Await1(mon, cnd, t) = 
  initialise.(N.t).t -> enqueue.mon.cnd.t.(N.t).t -> release.mon.t -> Await2(mon, cnd, t)

Await2(mon, cnd, t) = 
  isReady.(N.t).t.t?b -> if b then acquire.mon.t -> SKIP
                           else Park(mon, t); Await2(mon, cnd, t)

--NaturalQueue                           



ThreadInfo(n, t) = initialise.n!t -> ThreadInfoF(n, t)
ThreadInfoF(n, t) =  isReady.n!t?t2.false -> ThreadInfoF(n, t)
               [] setReady.n!t?t2 -> ThreadInfoT(n, t)
               --[] id.n.t -> ThreadInfoF(n, t) 
ThreadInfoT(n, t) = isReady.n!t?t2.true -> ThreadInfoT(n, t)
               [] setReady.n!t?t2 -> DIV
               [] initialise.n!t -> ThreadInfoF(n, t)

Queue'(m, c, qs) = 
     (null(qs)) & (isEmpty.m.c?t -> Queue'(m, c, qs))
  [] (not(null(qs))) & ( dequeue.m.c?t!head(qs) -> Queue'(m, c, tail(qs)))
  [] enqueue.m.c?t?tInfo:diff({n.t | n <- Node, t <- ThreadID}, set(qs)) -> Queue'(m, c, qs ^ <tInfo>)


init = mapFromList(<(c, <>) | c <- seq(ConditionID)>)

values(map) = Union({set(mapLookup(map, cnd)) | cnd <- ConditionID})

--assert init == (| C.0 => <>, C.1 => <>|)
--assert (seq(ConditionID) == <C.0,C.1>)

Queue(m, qMap) = 
  --    (empty(values(qMap))) & (isEmpty.m?c.t -> Queue(m, qMap))
  -- []  enqueue.m?c.t?tInfo:diff({N.t.t | (N.t) <- Node}, values(qMap)) 
  --       -> Queue(m, mapUpdate(qMap, c, mapLookup(qMap, c) ^ <tInfo>))
  -- 
  [] c2: ConditionID @ 
      ((not(null(mapLookup(qMap, c2)))) & 
      dequeue.m.c2?t!head(mapLookup(qMap, c2)) 
        -> Queue(m, mapUpdate(qMap, c2, tail(mapLookup(qMap, c2)))))
  [] (null(mapLookup(qMap, c2))) & (isEmpty.m.c2?t -> Queue(m, qMap))
  []  enqueue.m?c?t?tInfo:values(qMap) -> DIV
  []  enqueue.m?c.t?tInfo:diff({N.t.t | (N.t) <- Node}, values(qMap)) 
         -> Queue(m, mapUpdate(qMap, c, mapLookup(qMap, c) ^ <tInfo>))



    --removeFromMap(map, c, t) = mapUpdate(map, c, diff(mapLookup(map, c), {t}))

Unlocked(m) = acquire.m?t -> release.m.t -> Unlocked(m)

InitialiseMon0(m, setC) = 
  (Unlocked(m) ||| Queue(m, init) |||
  --(||| c <- setC @ Queue'(m, c, <>)) |||
  (||| t <- ThreadID @ ThreadInfo((N.t), t)) ||| InitLockSupp(m))

InitialiseMonDet0(m, setC) = 
  (Unlocked(m) ||| Queue(m, init) |||
  --(||| c <- setC @ Queue'(m, c, <>)) |||
  (||| t <- ThreadID @ ThreadInfo((N.t), t)) ||| InitLockSuppDet(m))



-- The set that synchronises with a set of threads using the monitor
SyncSet(m, setC) =
  union(External(m, setC), HideSet(m, setC))

SyncSet2(m, setC) =
  diff(Union({{|acquire.m | c <- setC|}, {|release.m | c <- setC|}, HideSet(m, setC)}),
       {})--{|wakeUp|})

--The set of events that are hidden when a thread uses the monitor
HideSet(m, setC) = 
  {|park.m, unpark.m, wakeUp.m, enqueue.m.c, dequeue.m.c, initialise,
    setReady, isReady, isEmpty.m.c | c <- setC|}


exports

channel acquire, release: MonitorID.ThreadID
channel callAcquire, callRelease: MonitorID.ThreadID
channel callAwait, callSignalAll: MonitorID.ConditionID.ThreadID
channel callSignal: MonitorID.ConditionID.ThreadID

-- The set of externally visible events
External(m, setC) = 
  {|callSignal.m.c, callAwait.m.c, callSignalAll.m.c, callAcquire.m, 
    acquire.m, callRelease.m, release.m | c <- setC|}


-- Runs the monitor with internal spurious wakeups
runWith(P, mon, setC) = 
  ((P [|SyncSet2(mon, setC)|] 
        InitialiseMon0(mon, setC)) \ HideSet(mon, setC))

-- Runs the monitor without internal spurious wakeups
runWithDet(P, mon, setC) = 
  ((P [|SyncSet2(mon, setC)|] 
        InitialiseMonDet0(mon, setC)) \  HideSet(mon, setC))
  

-- Operations on the monitor
Await(mon, cnd, t) = callAwait.mon.cnd.t -> 
                        Await1(mon, cnd, t)

Signal(mon, cnd, t) = callSignal.mon.cnd.t -> 
                        Signal1(mon, cnd, t)

SignalAll(mon, cnd, t) = callSignalAll.mon.cnd.t -> 
                            SignalAll1(mon, cnd, t)

Lock(mon, t) = callAcquire.mon.t -> 
                    acquire.mon.t -> SKIP

Unlock(mon, t) = callRelease.mon.t -> 
                    release.mon.t -> SKIP

endmodule
