\section{Conclusions and future work}

In this paper, we have examined a range of concurrency primitives offered by the Java Virtual Machine, Scala Concurrency Library module and a range of different lock designs. We have examined and proved the correctness of each of these whilst also proving complexity results and examining other properties. There are, however, some limitations to our work. 

Firstly, by the nature of model checking, we are only able to model a limited number of threads with restrictions on other parameters too. Though model checking with larger numbers of threads is technially possible, the exponential blow up in the number of states renders it practically infeasible. If a model is correct for small numbers of threads, we have significantly more confidence in the model remaining correct for larger numbers of threads; we do however note that this does not necessarily imply correctness. 

Take, for example, the SCL monitor which we have previously proved correct for six threads and two conditions in section \ref{section:SCLMonitor}. The components of each individual condition are distinct with the exception of the |ThreadInfo| objects; any flaw with this would be expected to show itself with only two conditions. Likewise any issue due to interfering threads must require at least seven interacting threads; this seems remarkably unlikely due to the simplicity of the system and limited possible interactions between threads. 

We have also only considered a number of specific concurrency primitives. Though our approach can be extended to many other primitives, this would still require significant work to verify the correctness of these. An automated translation system from normal code to CSP would aid in this task. Specialised examples do exist, such as SVA for shared variable programs \cite{RoscoeSVA}, however no mor general models exist. It is worth noting that any general translator would likely suffer from additional complexity blow up due to a lack of insight. An example of this can be seen in the SCL Monitor model, where a more natural implementation of the queue lead to state space- $n!$ times larger than a model with additional insight. Though a na\"{\i}ve translation is very feasible, the utility of such an approach is limited, though non-zero. Implementing an general automated translator, either optimised or na\"{\i}ve, is beyond the scope of the project and therefore left as further work. 