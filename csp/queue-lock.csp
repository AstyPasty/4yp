-- A lock based upon the test-and-set operation with fixed-time backoff.
--  * Based on Herlihy & Shavit, Section 7.4. 
--  * @param delay the time in nanoseconds to delay when conflict detected.

NTHREADS = 2
INTBOUND = 4
WAIT = B.0
GO = B.1

datatype NVariable = Flags
datatype Variable = State | Tail | A.NVariable.BoundedInt--Flags.{0..NTHREADS}
datatype ThreadID = T.{1..NTHREADS}--T0 | T1 | T2 | T3 | T4 
datatype BoundedInt = B.{0..INTBOUND}
subtype BoundedThreadInt = B.{1..NTHREADS}

subtype BInt = {0..INTBOUND}

channel atomic: Variable
channel delay: ThreadID
channel tryLock: ThreadID
channel lock : ThreadID
channel getAndSetb: ThreadID.Variable.Bool.Bool
channel getb: ThreadID.Variable.Bool
channel setb: ThreadID.Variable.Bool
channel getAndSetbi: ThreadID.Variable.BoundedInt.BoundedInt
channel getbi: ThreadID.Variable.BoundedInt
channel setbi: ThreadID.Variable.BoundedInt
channel getAndIncrement: ThreadID.Variable.Int
channel getAndIncrementBound: ThreadID.Variable.BoundedInt
channel getAndSeti: ThreadID.Variable.BInt.BInt
channel geti: ThreadID.Variable.BInt
channel seti: ThreadID.Variable.BInt
--channel getAndIncrement: ThreadID.Variable.BInt
--channel getAndIncrementBound: ThreadID.Variable.BInt

Spin = delay?t -> Spin

AtomicBool :: (Variable, Bool) -> Proc
AtomicBool(me, v) = getAndSetb?t!me!v?value -> AtomicBool(me, value)
            []   getb?t!me!v -> AtomicBool(me, v)
            []   setb?t!me?b -> AtomicBool(me, b)

AtomicInt :: (Variable, BInt) -> Proc
AtomicInt(me, v) = getAndSeti?t!me!v?value -> AtomicInt(me, value)
            []   geti?t!me!v -> AtomicInt(me, v)
            []   seti?t!me?i -> AtomicInt(me, i)
            []   getAndIncrement?t!me?v -> AtomicInt(me, v + 1)

AtomicBoundedInt :: (Variable, BoundedInt) -> Proc
AtomicBoundedInt(me, (B.v)) = getAndSetbi?t!me!(B.v)?value -> AtomicBoundedInt(me, value)
            []   getbi?t!me!(B.v) -> AtomicBoundedInt(me, (B.v))
            []   setbi?t!me?(B.i) -> AtomicBoundedInt(me, B.i)
            []   getAndIncrementBound?t!me!B.v -> if (v < NTHREADS) then AtomicBoundedInt(me, B.v+1) 
                      else if (v == NTHREADS) then AtomicBoundedInt(me, B.1)
                      else DIV

AtomicIntArray :: (NVariable, BInt) -> Proc
AtomicIntArray(me, init) = ||| n : {1..NTHREADS} @ AtomicInt(A.me.n, init)

AtomicBoundedIntArray :: (NVariable, BoundedInt, Int, Int) -> Proc
AtomicBoundedIntArray(me, init, s, e) = ||| n : {s..e} @ AtomicBoundedInt(A.me.B.n, init)


Lock :: (ThreadID) -> Proc
Lock(t) =  getAndIncrementBound.t.Tail?slot -> WaitForLock(t, slot)-- val slot = (tail.getAndIncrement * padding) % size
                  -- // slotIndices(ThreadID.get) = slot
                 -- mySlotIndex.set(slot)
WaitForLock :: (ThreadID, BoundedInt) -> Proc                 
WaitForLock(t, slot) = getbi.t.A.Flags.slot?v -> if v == WAIT then delay!t -> WaitForLock(t, slot) else Unlock(t, slot)-- while(flags.get(slot) == Wait){ } // spin on flag(slot)

Unlock :: (ThreadID, BoundedInt) -> Proc
Unlock(t, (B.slot)) =    -- val slot = mySlotIndex.get // slotIndices(ThreadID.get)
            setbi.t.A.Flags.(B.slot).WAIT -> -- flags.set(slot, Wait) // anyone waiting here must wait
            if slot < NTHREADS then setbi.t.A.Flags.(B.slot+1).GO -> NotHolding(t)-- flags.set((slot+padding)%size, Go) // next thread can progress
            else if slot == NTHREADS then setbi.t.A.Flags.(B.1).GO -> NotHolding(t)
            else DIV

NotHolding(t) = Lock(t)





AllThreads = ||| t : ThreadID @ NotHolding(t)
Components = Spin ||| AtomicBoundedInt(Tail, B.1) ||| AtomicBoundedIntArray(Flags, WAIT, 2, NTHREADS) ||| AtomicBoundedInt(A.Flags.B.1, GO)
AllChannels = {|getbi, setbi, getAndIncrementBound, getAndSetbi, delay|}


ActualSystem = (AllThreads [|AllChannels|] Components)

-- Obvious
assert STOP [T= AtomicInt(State, 1)
assert STOP [T= AtomicInt(A.Flags.1, 1)
assert STOP [T= AtomicIntArray(Flags, 1, 1, NTHREADS)
assert ActualSystem :[divergence free]
assert ActualSystem :[deadlock free]
assert STOP [T= ActualSystem
assert ActualSystem [T= STOP

-- Check that no two threads hold the lock at the same time
--CheckMutualExclusion = [] t: ThreadID @ getAndSetb.t.State.False.True -> setb.t.State?_.False -> CheckMutualExclusion
--assert CheckMutualExclusion [T= (ActualSystem\(Union({{|getb, delay|}, {getAndSetb.t.State.s | t <- ThreadID, s <- {True.True, True.False, False.False}}, {setb.t.State.s | t <- ThreadID, s <- {True.True, False.True, False.False}}})))--[[getAndSetb.T0.State.False.True <- enteringLock.T0]]) --, set.t.State?_!False <- exitedLock!t]])

-- Check no divergence before the lock is first held
CheckNoDiv = [] t: ThreadID, x : BoundedThreadInt @ getAndIncrementBound.t.Tail.B.1 -> STOP
             [] getbi.t.A.Flags.x.WAIT -> CheckNoDiv
             [] setbi.t?_ -> CheckNoDiv
             [] getAndIncrementBound.t?_ -> CheckNoDiv
             [] getAndSetbi.t?_ -> CheckNoDiv
noDivChannels = {|getbi, setbi, getAndIncrementBound, getAndSetbi|}
assert (ActualSystem [|noDivChannels|] CheckNoDiv) \ noDivChannels :[divergence free]

-- Check that divergence can occur before thread releases lock (ie. whilst lock is held)
CheckNoDiv2 = [] t: ThreadID, x : BoundedThreadInt @ setbi.t.A.Flags.x.WAIT -> STOP
             [] getbi.t.A.Flags.x.WAIT -> CheckNoDiv2
             [] setbi.t?_ -> CheckNoDiv2
             [] getAndIncrementBound.t?_ -> CheckNoDiv2
             [] getAndSetbi.t?_ -> CheckNoDiv2
             [] delay.t ->  CheckNoDiv2
noDivChannels2 = union(noDivChannels, {|delay|})
assert (ActualSystem [|noDivChannels2|] CheckNoDiv2) \ noDivChannels2 :[divergence free]

-- Check that divergence can't occur after lock release and before next obtained
CheckNoDivBetween = [] t: ThreadID, x : BoundedThreadInt @ setbi.t.A.Flags.x.WAIT -> CheckNoDiv3
             [] getbi.t.A.Flags.x.WAIT -> CheckNoDivBetween
             [] setbi.t?_ -> CheckNoDivBetween
             [] getAndIncrementBound.t?_ -> CheckNoDivBetween
             [] getAndSetbi.t?_ -> CheckNoDivBetween
             [] delay.t ->  CheckNoDivBetween

CheckNoDiv3 = [] t: ThreadID, x : BoundedThreadInt @ getAndIncrementBound.t.Tail.B.2-> STOP
             [] getbi.t.A.Flags.x.GO -> STOP
             [] getbi.t.A.Flags.x.WAIT -> CheckNoDivBetween
             [] setbi.t?_ -> CheckNoDivBetween
             [] getAndIncrementBound.t?_ -> CheckNoDivBetween
             [] getAndSetbi.t?_ -> CheckNoDivBetween
             [] delay.t ->  CheckNoDivBetween





