\section{Introduction}

%Speed Up necessity

In a world reliant on computer systems, the correctness of those systems are vital. Indeed, simple programming errors can lead to major, and sometimes fatal, incidents; examples of these include an automated trader losing \$460 million\cite{} and the Ariane flight V88 breaking up after launch due to an overflow error\cite{Flight501Failure}.

There are two main approaches to developing correct software - testing and verification. Though thorough unit testing can be effective in minimising software bugs\cite{MicroTest}, it is significantly less effective with concurrent code. This is predominantly due to the sheer number of different interactions between threads and the requirement to be able to both consider all interactions and model them. Linearizability testing is an effective alternative approach, although again this relies on the random testing of edge cases; clearly this is not exhaustive either\cite{LoweLin}.

By contrast, formal verification can be used to show that systems satisf\cite{}

% General correctness importance
% Concurrency - Therac \cite{BugSnag}
%Types of testing
%Why formal verification
%Contributions