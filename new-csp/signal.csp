module Signal(this, SignalID, ThreadID)
  include "variable.csp"

  include "SCL-CSP-analysis/JVMMonitor.csp"

  -- WaitNotify and Notifying are used to model the wait and notify functions
  -- WaitNotify tracks the waiting threads (for a given object), then once 
  -- a notify is receievd Notifying is used to notify the threads
  -- This is so that a notify doesn't have to sync with each thread 
  -- (particularly, so each notfy isn't blocking)


  -- The state variable for the signal object
  channel getState, setState : ThreadID . Bool
  stateChannels = {|getState, setState|}
  State = Var(false, getState, setState)


  -- The channels to represent a call of each of the methods offered by 
  -- the signal object
  channel signalUpAndWait, waitForSignalUp, signalDown : ThreadID
  signalChannels = {|signalUpAndWait, waitForSignalUp, signalDown|}

  -- Synchronize is used to model the synchronize blocks, only allowing 
  -- one thread to be performing actions on the Signal object at any one 
  -- time

  Thread(t) = signalUpAndWait.t -> JVMMonitor::Synchronized(t, SignalUpAndWait(t)); Thread(t)
        [] waitForSignalUp.t -> JVMMonitor::Synchronized(t, WaitForSignalUp(t));  Thread(t)
        [] signalDown.t -> JVMMonitor::Synchronized(t, SignalDown(t)); Thread(t)
  Threads = ||| t <- ThreadID @ Thread(t)

  SignalUpAndWait :: (ThreadID) -> Proc
  SignalUpAndWait(t) = getState.t?val ->
                            if val == true then DIV -- Required to be false
                            else setState.t.true ->
                                JVMMonitor::Notify(t); SignalWaitingForFalse(t)

  WaitForSignalUp :: (ThreadID) -> Proc
  WaitForSignalUp(t) = SignalWaitingForTrue(t)

  SignalDown :: (ThreadID) -> Proc
  SignalDown(t) = setState.t.false -> JVMMonitor::Notify(t); SKIP

  -- SignalUpAndWait :: (ThreadID) -> Proc
  -- SignalUpAndWait(t) = signalUpAndWait.s?t:ThreadID -> JVMMonitor::Synchronized(t, aSignalUpAndWait(t))
  -- aSignalUpAndWait(t) = getState.s.t?val ->
  --                           if val == true then DIV -- Required to be false
  --                           else setState.s.t.true ->
  --                               JVMMonitor::Notify(t); SignalWaitingForFalse(t)

  -- WaitForSignalUp :: (ThreadID) -> Proc  
  -- WaitForSignalUp(t) = waitForSignalUp.s?t:ThreadID -> JVMMonitor::Synchronized(t, aWaitForSignalUp(t))        
  -- aWaitForSignalUp(t) = SignalWaitingForTrue(t)

  -- SignalDown :: (ThreadID) -> Proc
  -- SignalDown(t) = signalDown.s?t:ThreadID -> JVMMonitor::Synchronized(t, aSignalDown(t))
  -- aSignalDown(t) = setState.s.t.false -> JVMMonitor::Notify(t); SKIP

  --  TODO - implement sliding timeouts on wait to simulate the spurious behaviour seen in Scala
  SignalWaitingForFalse :: ( ThreadID) -> Proc
  SignalWaitingForFalse(t) = getState.t?val ->
                            if val == false then SKIP
                            else JVMMonitor::Wait(t); SignalWaitingForFalse(t)
                                  
  SignalWaitingForTrue :: (ThreadID) -> Proc
  SignalWaitingForTrue(t) = getState.t?val ->
                            if val == true then  SKIP 
                            else JVMMonitor::Wait(t); SignalWaitingForTrue(t)

  Internals = JVMMonitor::runWith(Threads [|stateChannels|] Var)

exports
  spuriousWakeup = JVMMonitor::spuriousWakeup
endmodule


  -- The following s* processes are simplified versions of their 
  -- corresponding direct translations above
  -- We remove the synchronization and notifcation/wait functionality
  -- from the above; since state behaves atomically and only one thread 
  -- will be writing to state at any time under correct usage (child to 
  -- set up first then parent to set down) we can just wait until the 
  -- value of thread is changed to allow a 'wait' to end

  -- sSignalUpAndWait :: (SignalID, ThreadID) -> Proc
  -- sSignalUpAndWait(s, t) = signalUpAndWait.s.t -> getState.s.t?val ->
  --                                 if val == true then DIV -- Assertion
  --                                 else setState.s.t.true -> 
  --                                     getState.s.t.false -> SKIP

  -- sWaitForSignalUp :: (SignalID, ThreadID) -> Proc                                                        
  -- sWaitForSignalUp(s, t) = waitForSignalUp.s.t -> getState.s.t.true 
  --                         -> SKIP -- can terminate

  -- sSignalDown :: (SignalID, ThreadID) -> Proc
  -- sSignalDown(s, t) = signalDown.s.t -> setState.s.t.false -> SKIP 

