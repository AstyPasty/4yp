module LockSupport

  channel park: MonitorID.ConditionID.ThreadID
  channel wakeUp: MonitorID.ConditionID.ThreadID.Bool
  channel unpark: MonitorID.ConditionID.ThreadID.ThreadID

  LockSupport0 :: (MonitorID, ConditionID) -> Proc
  LockSupport0(m, c) = LockSupport(m, c, {}, {})
  LockSupport1(m, c, waiting, permits) =
    park.m.c?t -> (
      if member(t, permits)
        then wakeUp.m.c.t.true -> 
              LockSupport(m, c, waiting, diff(permits, {t}))
      else LockSupport(m, c, union(waiting, {t}), permits))
    []
    unpark.m.c?t?t2 -> (
      if member(t2, waiting)
        then wakeUp.m.c.t2.true -> 
              LockSupport(m, c, diff(waiting, {t2}), permits)
      else LockSupport(m, c, waiting, union(permits, {t2})))

  LockSupport(m, c, waiting, permits) =
    if waiting == {} then LockSupport1(m, c, waiting, permits)
    else (LockSupport1(m, c, waiting, permits)
      |~| wakeUp.m.c$t:waiting!false -> 
           LockSupport(m, c, diff(waiting, {t}), permits))

exports

  InitialiseLockSupp(s) = LockSupport0(s)

  Park(m, c, t) = park.m.c.t -> SKIP

  Unpark(m, c, t, t') = unpark.m.c.t.t' -> SKIP

endmodule