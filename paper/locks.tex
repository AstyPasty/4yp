\section{Modelling and analysing implementations of locks}
\label{sec:locks}



% \inlineScala

%In this section we will analyse a number of different lock implementations. 

The primary purpose of locks is to provide \emph{mutual exclusion} between threads; that is to avoid two threads from operating concurrently on the same section of code, referred to as the \emph{critical region}. A good lock should also fulfil some \emph{liveness} requirements, essentially that something good will eventually happen assuming no thread holds the lock indefinitely. We examine how we can model certain liveness and safety properties using CSP, present a number of different locks and test if the expected properties hold.

%When devising liveness requirements we assume that no thread wil hold the lock indefinitely; otherwise most reasonable liveness requirements can be invalidated by a thread that gains the lock and never releases it. \emph{Deadlock freedom} is a liveness requirement that if some thread is attempting to acquire the lock then some thread will eventually succeed in acquiring the lock, unless a thread holds the lock indefinitely. \emph{Starvation freedom} is a liveness requirement that any thread that tries to gain the lock will eventually succeed; by contrast deadlock freedom allows one thread to never obtain the lock as long as others complete an infinite number of critical sections. Other requirements/useful properties of locks will be explored later.

\subsection{The interface}

%The most straightforward interface of a lock can be seen in Figure \ref{code:LockInterface}. This provides a |lock| function for a thread to attempt to gain the lock (blocking if some other thread currently hold the lock) and an |unlock| function for a thread to release the lock. 

The most straightforward interface of a lock can be seen in Listing \ref{code:LockInterface}. It provides a |lock| function which allows a thread to attempt to gain the lock (blocking if some other thread currently hold the lock) and an |unlock| function for the holder of the lock to release it. 

\begin{scala}[caption={A Scala interface for a simple lock},label={code:LockInterface}]
  trait Lock{
    /** Acquire the Lock. */
    def lock : Unit
    /** Release the Lock. */
    def unlock : Unit 
    ...
  }
\end{scala}

%When a thread |t| uses a lock |l| with there are four main events of importance to model in CSP:

%There are four main events of interest to model when a thread interacts with a lock over these two functions: %revisit wording

There are four main actions a thread can take that we will need to consider when we model the locks:

\begin{itemize}
  \item A thread calling the |lock| function.
  \item A thread acquiring the lock; this is the linearization point of the |lock()| fucntion.
  \item A thread releasing the lock; this is the linearization point of the |unlock()| fucntion.
  \item A thread terminating or reaching a state where it will make no further attempts to acquire the lock.
\end{itemize}

These events can be modelled via events on the CSP channels \newline |callLock, lockAcquired, lockReleased : LockID . ThreadID| and |end : ThreadID| respectively. We assign each thread an identity of the datatype |ThreadID = T.{0 .. NTHREADS - 1}| and each lock is given an identity of the datatype |LockID = L.{0..NLOCKS-1}|.

Throughout the paper, we will use the convention of |callX| to represent a thread calling function |X| and |end.t| to represent a thread that will no longer perform any operations on the corresponding synchronisation object 

\subsection{Properties of locks}\label{section:lock-properties}

We now specify some ideal properties of locks using the aforementioned channels.

\subsubsection{Mutual exclusion}\label{mutual-exclusion}
Mutual exclusion is a safety property which states that at most one thread can hold the lock at any points. Mutual exclusion is specified by the following trace refinement which specifies that the thread holding the lock must release the lock before some other thread can acquire it.

%This specifies that at most one thread may be in its critical section at any one time; i.e.~that once thread A obtains the lock, no other thread can obtain the lock until thread A unlocks. We can therefore deduce that a lock |l| with model |X| satisfies the trace refinement:  
  
  \begin{cspm}
    Mutex = lockAcquired.l?t -> lockReleased.l.t -> Mutex
    assert Mutex [T= 
              X \ (£$\Sigma$£ - [|lockAcquired.l, lockReleased.l|])
  \end{cspm}

\subsubsection{Deadlock-freedom}\label{deadlock-freedom}
This is a liveness property which specifies that if a thread attempts to acquire the lock then some thread will succeed in acquiring the lock \cite{TAoMP}. 

%This does allow a CSP deadlock \framebox{Need to explain earlier} if no thread is attempting to acquire the lock, but only if the following holds: \framebox{format this}
  
  % $\forall(s,ref) \in failures(P) \, . \,\, \#(s \downarrow callLock)= \#(s \downarrow lockAcquired) \implies ref \subset \Sigma $
  
  % This can be captured by the following failures refinement on lock |l| with the set of all threads called |ThreadID|. This process can non-deterministically deadlock when no threads are attempting to obtain the lock and otherwise ensures that if a thread attempts to acquire the lock then some thread obtains the lock

  We can capture this in the stable-failures model by ensuring that |lockAcquired.l| is always available to be communicated when some thread has called the lock but not yet obtained it. %revisit:wording

  \begin{cspm}
AcquireLock :: (LockID, {ThreadID}, {ThreadID}) -> Proc
AcquireLock(l, ts, TS) = 
     end?t:(diff(TS, ts)) -> AcquireLock(l, ts, diff(TS, {t})) 
  [] callLock.l?t:(diff(TS, ts)) -> AcquireLock(l, union(ts, {t}), TS)
  [] lockAcquired.l?t:ts -> AcquireLock(l, diff(ts, {t}), TS)

assert AcquireLock(l, {}, ThreadID) [F= 
          X \ (£$\Sigma$£ - {|callLock.l, lockAcquired.l, end|})
  \end{cspm}
  % |AcquireLock| takes two parameters: |l| is the identity of the lock and |ts| is the set of threads currently which have communicated a |callLock| but haven't yet acquired the lock. In our refinement check, we will assume that no lock events have occurred prior; ie. no threads have already attempted to acquire the lock. %\framebox{Explain lack of end}
  |AcquireLock| takes three parameters: |l| is the identity of the lock, |ts| is the set of threads which have communicated a |callLock| but haven't yet acquired the lock. Finally, |TS| is the set of all threads that have not communicated an |end.t|; this is so that we can accurately restrict the specification to block any terminated threads from calling the lock. 

% \subsubsection{Livelock-freedom}\label{livelock-freedom}
% %This specifies that the system must make actual progress; i.e.~that threads can't repeat actions indefinitely without making any progress. 
% This requirement specifies that the number of internal actions on a lock must be bounded while no thread holds the lock; i.e.~threads can't indefinitely repeat actions whilst the lock is unheld. We cannot directly capture this in CSP as we are unable to restrict 

% This can be captured in the failures-divergences model, using a specification process parametised over lock |l| and a failures-divergences refinement against a system that only has |lockAcquired| and |lockReleased| as visible communications.

% \begin{cspm}
% Live(l) =   lockAcquired.l?t -> DIV
%                   |~| STOP

% assert Live(l) [FD= X \ (£$\Sigma$£ - [|lockAcquired.l, lockReleased.l|])
% \end{cspm}

% This specification only diverges after the lock has been acquired for the first time; . It also allows no thread to acquire the lock but only if a finite number of internal events have occured. 

% This specification allows the lock to diverge only when it is held by some thread and to be divergence free otherwise. This forces the number of internal actions when the lock is not held to be finite (else it could diverge and the refinement would fail), indicating that no livelock has occured. We allow the specification to non-deterministically |STOP| when the lock is unheld; this models the effective behaviour of the lock after all threads terminate.

\subsubsection{Initial Livelock-Freedom}\label{initial-livelock-freedom}

We also check that the lock can be obtained for the first time in a finite number of internal operations. We do this by hiding the internal events and use the failures-divergences model to assert that a divergence can only occur after some |lockAcquired| event.

\begin{cspm}
Live(l) =   lockAcquired.l?t -> DIV
                  |~| STOP

assert Live(l) [FD= 
          X \ (£$\Sigma$£ - [|lockAcquired.l|])
\end{cspm}

We include the nondeterministic choice to |STOP| to cover the case where all threads terminate via an |end|.

These are three important properties of useful locks; we will consider starvation-freedom later.

%Remove Lock specification???

% \subsection{A simple lock specification} 

% Listing \ref{code:LockSpec} shows a simple stable-failures specification for a lock which offers mutual exclusion and deadlock-freedom. Here |l| is the identity of the lock and |ts| is the set of threads that can interact with the lock. 

% %This specification has the required property of mutual exclusion - once a thread has performed a |lockAcquired.l.t|, no other threads can acquire the lock until after the lock has been released. It also satisfies deadlock-freedom since it can always communicate a |callLock| unless either |ts == TS| (in which case some thread can communicate a |lockAcquired| then |lockReleased|) or |TS = {}| (where all threads have 'terminated' via |exit| and hence is deadlock-free since no threads will attempt to obtain the lock). Livelock-freeness is also satisfied as all actions performed make progress towards obtaining the lock or releasing the lock once it is held. 

% \begin{cspm}[caption={A non-starvation-free trace specification for a lock}, label={code:LockSpec}]
% SpecLock(l) = lockAcquired.l?t -> lockReleased.l.t -> SpecLock(l)
% SpecThread(l, t) =    
%      callLock.l.t -> lockAcquired.l.t -> lockReleased.l.t -> SpecThread(l, t)
%   [] end.t -> STOP

% LockSpec(l, ts) = SpecLock(l) [|{|lockAcquired.l, lockReleased.l|}|]
%                       (||| t <- ThreadID @ SpecThread(l, t))
% \end{cspm}

% This specification has the properties of mutual exclusion, deadlock-freedom and initial livelock-freedom; we have verified this by running the three assertions from \ref{mutual-exclusion}, \ref{deadlock-freedom} and \ref{initial-livelock-freedom}. We therefore have that any process which refines under stable-failures this specification is also also fulfils the properties of mutual exclusion and deadlock-freedom. Since the specification does not diverge, we cannot use this specification to check by assertion that a lock does not diverge before it is first held; the following locks can each diverge after first being held whereas this specification cannot. %revisit CHECK

\subsection{Test-and-Set lock}

The Test-and-Set (TAS) lock implementation (from \cite{CADS}) can be seen in Listing \ref{fig:TASScala}. Internally, it uses an |AtomicBoolean| variable |state| to capture whether the lock is currently held, with |true| indicating that some thread holds the lock and |false| otherwise. The |AtomicBoolean|, has atomic |get| and |set| operations to read and write values respectively. It also has a |getAndSet| operation which atomically sets the value of the Boolean and returns the old value. A thread can obtain the lock via a |getAndSet(true)| where |state| was previously |false|; this is the linearization point of the |lock()| function. % that no thread previously held the lock; the thread can then release the lock by setting the value back to |false|.%When a thread attempts to obtain the lock, it performs a |state.getAndSet(true)|; a |getAndSet(true)| that returns |false| can be treated as having gained the lock, whereas a |true| indicates that some other thread already holds the lock. To release the lock a |set(false)| is done to mark the lock as available to other threads.


  \begin{scala}[caption={Test-and-set lock from \cite{CADS}}, label={fig:TASScala}]
import java.util.concurrent.atomic.AtomicBoolean

/** A lock based upon the test-and-set operation 
  * Based on Herlihy & Shavit, Chapter 7. */
class TASLock extends Lock{
  /** The state of the lock: true represents locked */
  private val state = new AtomicBoolean(false)

  /** Acquire the Lock */ 
  def lock = while(state.getAndSet(true)){ }

  /** Release the Lock */
  def unlock = state.set(false)
}
  \end{scala}

\inlineCSP

In order to model the TAS lock, we first need a process that acts as an |AtomicBoolean| to model the |state| variable. Listing \ref{csp:Variable} introduces a process |AtomicVar| than takes an initial value of type |T|, channels |get, set : ThreadID.T| and |getAndSet : ThreadID.T.T| for some arbitrary type |T|.

  \begin{cspm}[caption={A process encapsulating an Atomic variable with get, set and getAndSet operations},label={csp:Variable}]
AtomicVar(value, get, set, gAS) = 
     get?_!value -> AtomicVar(value, get, set, gAS)
  [] set?_?value' -> AtomicVar(value', get, set, gAS)
  [] gAS?_!value?value' -> AtomicVar(value', get, set, gAS) 
  \end{cspm}

We can therefore represent the |state| variable from the Scala implementation by the following CSP:
\begin{cspm}
  channel get, set: ThreadID . Bool
  channel getAndSet: ThreadID . Bool . Bool
  State = AtomicVar(false, get, set, getAndSet)
  InternalChannels = {|get, set, getAndSet|}
\end{cspm}
A communication on any of these channels is equivalent to a thread calling the corresponding operation in Scala. We use |false| to indicate that no thread holds the lock initially.

We next model the operations of the lock; both operations are trivial to convert to CSP.
\begin{cspm}
  Unlock(t) = setState.t!False -> SKIP 

  Lock(t) = getAndSet.t?v!True -> if v == False then SKIP 
                                    else Lock(t)
\end{cspm}

% The |Lock| procedure is also trivial, with the thread just communicating over |getAndSet|. The procedure terminates once the |getAndSet| communicates that the original value of the |state|variable was false; a |getAndSet.t.False.True| event in a trace can be linearized as the point at which the thread |t| obtains the lock.


We model the threads that are attempting to obtain the lock by a process |Thread(x)| with thread identity |x|. Each thread can non-deterministically chooses to either terminate or attempt to obtain the lock, release the lock and repeat. %; we use external choice here so that we can regulate the  behaviour of the threads when analysing the lock's properties. 
Here we use |L.0| as the identity of the lock.

\begin{cspm}
  Thread(t) =   £$\,$£callLock.L.0.t -> Lock(t); Unlock(t); Thread(t)
              [] end.t -> SKIP
\end{cspm}

Finally, we construct the lock from its components. We first synchronise all the threads over the |get|, |set| and |getAndSet| channels with the |State| process. Since \newline|getAndSet.t.False.True| and |setState.t.False| represent the linearization points of the |lock()| and |Unlock()| operations, we can rename these communications to |lockAcquired.L.0.t| and |lockReleased.L.0.t| respectively to produce |ActualSystemR|. Finally, to obtain a system that only visibly communicates the four previously identified events, we hide the internal channels of the lock to produce |TASLock|. %revisit: diagram?

%\framebox{Diagram?}

\begin{cspm}
  -- All initially do not hold the lock
  AllThreads = ||| t : ThreadID @ Thread(t)
  -- Allow all threads to peform actions on the state variable
  ActualSystem = (AllThreads [|InternalChannels|] State)
  -- Rename lock acquisition and releasing and hide internal events
  ActualSystemR = ActualSystem 
                    [[getAndSet.t.False.True <- lockAcquired.L.0.t, 
                     £$\!\!\:\:\!\!\:\!\:$£set.t.False            £$\!\!\:\:\!\!\:\!\;$£<- lockReleased.L.0.t  | t <- ThreadID]]
  TASLock = ActualSystemR \ InternalChannels
\end{cspm}

\subsubsection{Analysis}

We firstly examine whether this model fulfils the aforementioned properties. The mutual exclusion, deadlock-freedom and initial-livelock-freedom tests from section \ref{section:lock-properties} pass as expected. The model can, however, diverge whenever the lock is held. This occurs when a thread (or threads) attempting to obtain the lock perform an infinite number of |getAndSet| operations. An example trace of this behaviour follows
\begin{cspm}
  £$\langle$£callLock.l.T.0, callLock.l.T.1, getAndSet.T.0.False.True£$\rangle$£^
    £$\langle$£getAndSet.T.1.True.True£$\rangle^\omega$£
\end{cspm}
  
This is expected; thread |T.1| is trying to obtain the lock and is being blocked by |T.0| which holds the lock. This behaviour is, however, problematic for low-level performance. Any |getAndSet| operation causes a broadcast on the shared memory bus between the processors, delaying all processors \cite{TAoMP}. This also forces each thread to invalidate the value of |state| from the caches, regardless of whether the value has actually been changed. Since the above trace never results in thread |T.1| successfully setting |state|, it is preferrable to limit the number of |getAndSet| operations without delaying a thread from obtaining the lock. As a result, we use less costly |get| operations in order to reduce the usage of |getAndSet| operations; the |getAndSet| operations are now limited to situations where they are likely to obtain the lock. Since |get| does not change the underlying value of a variable, the read will result in at most one cache-miss per |set|/|getAndSet| on |state|; this is a marked improvement. This change yields the Test-and-Test-and-Set (TTAS) lock.%\framebox{Level of detail regarding memory buses, performance, caching etc} %COUNT


\subsection{Test-and-Test-and-Set lock}


\begin{scala}[caption={TTAS lock from \cite{CADS}}, label={scala:TTAS}]
class TTASLock extends Lock{ 
  £\dots£
  /** Acquire the lock */
  def lock = 
    do{
      while(state.get()){ } // spin until state = false
    } while(state.getAndSet(true)) // if state = true, retry
  £\dots£
}
\end{scala}

The TTAS lock makes use of this improvement, whilst otherwise remaining similar to the TAS lock. The sole change is to the |lock| function, as can be seen in Figure \ref{scala:TTAS}, which we then specify in our CSP model as the following: 
\begin{cspm}
Lock(t) =  get.t?s -> if s = True then Lock(t)
                      else getAndSet.t?v!True -> if v = False then SKIP
                                                 else delay!t -> Lock(t)
\end{cspm}
The TTAS lock can still produce traces with threads performing an unbound number of consecutive operations, however these are now |get| operations instead of |getAndSet| operations. %Whereas the TAS lock can have an unbounded number of |getAndSet| operations for each time the lock is obtained, the 
The TTAS lock has performs at most one |getAndSet| operation per thread when the lock becomes available. This is the case when the thread's last communication was |get.t.False|, indicating that the lock is available and hence the thread attempts to acquire the lock via a getAndSet.

We now have a linear bound on the number of unsuccessful getAndSet operations, resulting in much more efficient usage of caching and shared memory. This has been verified by synchronising with a regulator process which outputs on an error channel if |n| |getAndSet|s occur in one locking cycle; this regulator acts as a watchdog. Since the trace refinement is satisfied, we have that no |error| event has been communicated and hence at most |card(ThreadID)| |getAndSet| events can occur every time the lock is released. %low-revisit:put check on left?

\begin{cspm}
channel error
Reg(x) =    gASState?_ -> if (x < card(ThreadID)) then Reg(x+1)
                          else error -> STOP
         [] lockReleased?_ -> Reg(0)

assert LockSpec(L.0, {}, ThreadID) 
         [T= ActualSystemR [|{|gASState, lockReleased|}|] Reg(0)
\end{cspm}

\subsection{Peterson lock}\label{section:peterson-lock}

The Peterson lock is a lock implementation for two threads that provides mutual exclusion, deadlock-freedom and starvation-freedom between threads \cite{Peterson}.

\begin{scala}[caption={The Peterson lock code, adapted from \cite{CADS}}]
import ox.cads.util.ThreadID
import java.util.concurrent.atomic.AtomicIntegerArray

class PetersonLock extends Lock{
  private val flag = new AtomicIntegerArray(2)
  @volatile private var victim = 0

  def lock = {
    val me = ThreadID.get; val other = 1-me 
    assert(me==0 || me==1, 
      "ThreadID needs to be 0 or 1.  Try calling ThreadID.reset first")
    flag.set(me, 1); victim = me
    while(flag.get(other) == 1 && victim == me){ } // spin
  }

  def unlock = { val me = ThreadID.get; flag.set(me, 0) }
}
\end{scala}

We now construct the CSP model of the Peterson Lock. We first introduce |IntArray|; this is similar to the |AtomicVar| process earlier but has an index allowing it to store multiple values simultaneously. We also have parameters |l| and |u| which specify the lower and upper bounds of the integers stored by |IntArray|; without this each |Entry| could theoretically store $2^{32}$ values, which results in FDR generating an infeasibly large state space. We do not include the |getAndSet| operation here as we do not use it in the Peterson lock; it could however be modelled similarly to |AtomicVar|.

\begin{cspm}
IntArray(Ind, init, getI, setI, l, u) = 
  let Entry(index, value) = 
            get!index?_!value -> Entry(index, value)
         [] setI!index?_?value': {l..u} -> Entry(index, value')
  within ||| index : Ind @ Entry(index, init)
\end{cspm}

We also make a couple of changes to the CSP model compared to the direct translation. Firstly, we store all three variables in the |IntArray| with |victim| is at index 2; this allows us to use the same |get| and |set| channels throughout for clarity. We also bound the |IntArray| to store values in the range |{0..1}|. The rest of the model is a fairly natural translation of the Scala code and we model threads as before.

\begin{cspm}[caption={The CSP implementation of the Peterson Lock}]
channel get, set: Index.ThreadID.{0,1}

Variables = IntArray(Index, 0, get, set, 0, 1)
InternalChannels = {|get, set|}

Lock :: (ThreadID) -> Proc
Lock(T.x) =  set.I.x.T.x.1 -> set.I.2.T.x.x -> WhileLock(T.x)

WhileLock(T.x) = 
     get.I.1-x.T.x.0 -> SKIP -- Hold lock
   [] get.I.1-x.T.x.1 ->  get.I.2.T.x?y ->
                         if x == y then WhileLock(T.x) -- Spin
                         else SKIP -- Hold lock

Unlock :: (ThreadID) -> Proc
Unlock(T.x) = set.I.x.T.x.0 -> SKIP

Thread(T.x) =     callLock.L.0.T.x -> Lock(T.x); Unlock(T.x); Thread(T.x)
              |~| end.t -> SKIP

PetersonLock = ((AllThreads [|InternalChannels|] Variables)
                  [[get.I.(1-t).T.t.0 <- lockAcquired.L.0.T.t,
                  get.I.2.T.t.(1-t) <- lockAcquired.L.0.T.t,
                  set.I.t.T.t.0 <- lockReleased.L.0.T.t | t <- {0, 1}]])
\end{cspm}

We can then interleave the two threads, synchronise with the |IntArray|, rename the lock acquistion and released events, and hide all internal communications. Similarly to before we use the refinements to show that this lock satisfies the properties of mutual exclusion and deadlock- and initial-livelock-freedom. We now consider showing the propety of starvation-freedom.

% \subsection{Tree lock}

% \framebox{Might be worth introducing Peterson lock for starvation freedom both earlier and here?}

% Suppose we have an implementation of a lock that works for upto n threads and now wanted to extend this to work with more threads trying to obtain a single lock. One approach to solving this problem is to arrange a number of the n thread locks into a tree structure. The threads are assigned a leaf node and, once they have obtained that lock, they progress up the tree obtaining the next lock and so on. Once the thread reaches the root of the tree and has obtained the 'root lock' and hence holds the lock; to unlock, the thread unlocks the root lock and progressively unlocks all the locks it held until it is back at the leaf lock. To consider a simple case where n = 2 and NThreads = 8 we have the following structure: \framebox{Draw properly}

% \begin{figure}
% \begin{verbatim}
%                                   L.0
%                                 /     \                    
%                                /       \
%                               /         \
%                              /           \
%                            L.1           L.2
%                           /  \           /  \
%                          /    \         /    \
%                         /      \       /      \
%                        L.3     L.4    L.5     L.6
%                       /  |     / |    |  \    |  \
%                      /   |    /  |    |   \   |   \
%                  T.3.1   | T.4.1 |    | T.5.2 |   T.6.2
%                       T.3.2   T.4.2    T.5.1   T.6.1
% \end{verbatim}
% \caption{An example of the tree lock with 2 threads per lock and 8 threads \label{fig:Tree}}
% \end{figure}

% Here, for T.5.1 to obtain the root lock L.0, it must first obtain L.5 then L.2 then it can attempt to lock L.0. If it holds L.0 then all of the other 7 threads can't enter their critical section. Once T.5.1 wants to release the lock it unlocks L.0, then unlocks L.2 then finally unlocks L.5. T.5.1 can now either terminate or try to reobtain the root lock.

% \subsubsection{Modelling}

% We model the tree structure so that the structure of the tree is independent from the implementation of the individual locks; this will allow us to examine how different the different properties of the locks affect the overall structure.

% For convenience, we shall call the threads |T.{y}.{z}| where y is the leaf lock that the thread will first try and obtain and z is just an index over the threads starting at that leaf lock. Since the thread should be agnostic to the implementation of the lock, the thread initially either exits or calls |LockTree| to try and obtain the lock. Once the thread has obtained the lock, it then releases it by a call to |UnlockTree|. Both |LockTree| and |UnlockTree| are recursively defined, traversing their way up and down the tree respectively before terminating once they have locked the root lock or unlocked a leaf lock respectively. 
% |nextUnlock(x, y)| is used as a helper function to generate the next lock to release 

% \begin{cspm}
%   nextUnlock(x, y) = if (y / 2 > x) then nextUnlock(x, y/2) else L.y 

%   LockTree(t, L.0) = SKIP
%   LockTree(T.y.z, L.x) = Lock(T.y.z, L.x); LockTree(T.x.y, L.((x-1)/2))

%   UnlockTree(T.y.z, L.x) = if (x == y) then Unlock(T.y.z, L.x); SKIP
%                            else Unlock(T.y.z, L.y); 
%                                 UnlockTree(T.y.z, nextUnlock(x, y))

%   Thread(T.y.z) = callLock.L.y.T.y.z -> LockTree(T.y.z, L.y); 
%                                           UnlockTree(T.y.z, L.0); 
%                                           Thread(T.y.z)
%                  [] end.T.y.z -> SKIP
% \end{cspm}

% We can use the |lockAcquired| and |lockReleased| events of the root |L.0| lock as the points where a given thread obtains and releases the lock and the |callLock| events of the leaf nodes to represent when a thread tries to access the lock. To check that this lock fulfils the required properties we will hide all internal locking events; we do not care how the lock functions internally as long as it follows the required specifications. We will also rename the the three above events to appear to occur on the lock L.0. The system is therefore constructed as follows:

% \begin{cspm}
%   -- Initialise threads to not hold their locks
%   AllThreads = ||| (T.y.z) : ThreadID @ Thread(T.y.z)
%   -- Initialise all the locks
%   AllLocks = ||| (L.x) : LockID @ LockSystem(L.x)
%   -- Sychronise the threads with all the locks
%   TreeInternal = (AllThreads [|LockEvents|] AllLocks)
%   -- Hide unwanted lock events from internal locks
%   TreeHidden = TreeInternal \ Union(diff({|lockAcquired|}, {|lockAcquired.L.0|}), 
%                                      diff({|unlockedLock|}, {|unlockedLock.L.0|}),
%                                      diff({|callLock|}, 
%                                             {callLock.L.y.T.y.z | T.y.z <- ThreadID}))
%   -- Rename linearization points so all refer to L.0
%   TreeInternalRenamed = TreeHidden [[callLock.L.x.t <- callLock.L.0.t]]
% \end{cspm}

% \framebox{Add analysis of behaviours with different node locks etc}


\subsubsection{Starvation-Freedom} \label{starvation-freedom}

Starvation-freedom is a liveness property that states that, under the assumption that no thread holds the lock indefinitely, every thread that attempts to acquire the lock eventually succeeds \cite{TAoMP}. It requires that any thread attempting to gain the lock must can only be bypassed by other threads a finite number of times.

One common approach to checking infinite properties in CSP is to hide some (in this case internal) channels and then check that the model does not diverge. This approach does not work here: consider a starvation-free lock which uses busy waiting (repeatedly testing if the lock is available). We have that hiding the internal communications results in a divergence, however the lock is starvation-free. An example of such a lock is the Peterson lock which we examine in section \ref{section:peterson-lock}.

Roscoe and Gibson-Robinson showed that every infinite traces property that can be captured by CSP refinement can also be captured by a finite-traces refinement check when combined with the satisfaction of a deterministic B{\"u}chi automaton \cite{RoscoeBuchi}. A B{\"u}chi automaton is an automaton that takes infinite inputs and accepts an input if an accepting state is visited infinitely often \cite{CAFV}. We can, however, show that no deterministic B{\"u}chi automaton can capture starvation-freedom. 

% The automaton should be satisifed by any trace where some thread obtains the lock; this requires that the BA has some accepting state that can be visited an infinite amount of times when some thread |t| holds the lock. Since BA have a finite number of states, that state must be reachable in a finite sequence of steps. As a result, the BA must be satisfied by some thread obtaining the lock, reaching an accepting state in the BA, releasing the lock and repeating that same process. This, however, would accept non-starvation free locks.

% We need at least one accepting state where some thread holds the lock. Otherwise the automaton would reject a starvation free lock with some trace where a thread obtains the lock and never releases it. At least one of these accepting states must be visitable an infinite number of times.

% We can't have an accepting state where some thread holds the lock. Consider a lock that is not starvation free and suppose one thread (wlog.~|T.0|) calls the lock. Some other thread (wlog.~|T.2|) calls the lock, acquires it and releases it without the original caller making any progres

% We have that the BA should be satisfied by a run where some thread immediately obtains a lock and never releases it. We can therefore conclude that any BA must have at least one accepting state where some thread holds the lock and that some subset of the accepting states can be reached infinitely often.

% Now suppose we have a 2-threaded lock which is not starvation free. 

% Suppose we have a 2-threaded lock which is starvation free. The BA should be satisfied by a run where thread |T.1| proceeds and is permanently descheduled before obtaining the lock 

We will show by contradiction that no such deterministic automaton $B$ can capture starvation-freedom. Let us without loss of generality consider 2-threaded locks. 

By the definition of starvation-freedom, the automaton should be satisfied if |T.0| acquires and never releases the lock and |T.1| attempts to acquire the lock. The automaton therefore must have some accepting state which is visited an infinite number of times when |T.0| holds the lock and |T.1| attempts to acquire it; we will call this state $q_{a}$.

%the repeated actions of the threads cause (a subset of) the accepting states to be visited infinitely often.

% Now suppose that |T.0| again holds the lock and |T.1| is attempting to acquire the lock. By the above, we have that there is some reachable accepting state in the automaton where this is the case; we run until we reach this state and then |T.0| releases the lock. |T.0| then reobtains the lock successfully - we have that the automaton can not block this behviour, else it excludes the starvation-free lock where |T.1| can only obtain the lock when |T.0| has acquired and released the lock an even number of times. Again, since |T.0| could hold the lock indefinitely, we have that some accepting state must be reachable where |T.0| holds the lock and |T.1| is attempting to acquire the lock. Once we reach this state, |T.0| can release the lock and repeat this cycle. Since this cycle can be repeated indefinitely, we have that this is required to be an accepting run if the lock is starvation free. However, we have that the run is accepted even if the lock is not starvation-free; an example being the TAS lock from before as the only communication |T.1| makes whilst trying to obtain the lock unsuccessfully is via same |getAndSet.l.T.1.true.true| communication). 

% We therefore have that we have shown by construction that a general, deterministic B{\"u}chi automaton for starvation-freeness cannot exist.

Now we consider the TAS lock from before. This is clearly not starvation-free as the first thread to communicate on |getAndSet| once the lock becomes available will acquire it; this allows some thread to infinitely bypass some other waiting thread. Consider an execution where |T.0| repeatedly acquires and releases the lock, bypassing |T.1| which is repeatedly attempting and failing to obtain the lock. This execution, however, passes through the state $q_{a}$ of $B$ every time |T.0| acquires and later releases the lock. This can occur an infinite number of times, resulting in $B$ accepting this execution. This is a contradiction as this execution is not starvation-free (|T.1| never obtains the lock) however it still satisfies $B$.


% Now we consider the TAS lock from before. This is clearly not starvation free as the first thread to communicate on |getAndSet| once the lock becomes available will acquire it. As a result |T.0| can bypass |T.1| an infinite number of times, hence the TAS lock is not starvation free. We have from the above that there must exist some accepting state in the automaton which is reachable when |T.0| holds the lock and |T.1| is attempting to obtain the lock. Since |T.1| only has one available state when |T.0| holds the lock (communicating a |getAndSet.L.0.T.1.false.false|), we have that this accepting state must be reachable whenever |T.0| bypasses |T.1|. As a result, we have that |T.0| can obtain the lock an infinite number of times, and each of these bypasses can result in a visit to an accepting state of the automaton. We therefore have that the B{\"u}chi automaton accepts this run despite the both the run and the TAS lock not being starvation-free. This is a contradiction and hence we have that no such deterministic automaton can exist.

\framebox{Improve}We hence have that no deterministic B{\"u}chi automaton can capture starvation-freedom and hence we cannot test directly for starvation-freedom through a standard FDR refinement check.

\subsection{First-come-first-served}

We can instead consider capturing the stronger property of first-come-first-served. Locks that satisfy this property can be split into a \emph{doorway} section of a bounded number of steps and a folowing \emph{waiting} section of a potentially unbounded number of execution steps. This property states that once thread |X| has completed its doorway section it cannot be overtaken by a thread |Y| that has not yet started its doorway section; i.e.~ |X| must acquire the lock before |Y| acquires the lock. We note that first-come-first-served implies starvation-freedom.

Checking this propety requires manual renaming of some communication(s) to a new channel |doorwayComplete : LockID . ThreadID|. The implementation here requires the user to identify the doorway section manually; an automated doorway detector is left as future work.

The CSP specification of first-come-first-served is defined in Listing \ref{CSP:FCFS}. This is split into four main processes:
\begin{itemize}
  \item |FCFSNotStarted(l, t, b, bn)| indicates that thread |t| has not called the lock yet. |t| can either terminate via an |end| or call the lock.
  \item |FCFSStarted(l, t, b, bn)| indicates that thread |t| has called the lock and started, but not completed, its doorway section.
  \item |FCFSCompleted(l, t, b, bn)| indicates that thread |t| has completed its doorway section and is ready to obtain the lock. When it obtains the lock, it transitions back to |FCFSNotStarted(l, t, b, bn)|.
  \item |FCFSTerminated(l, t)| is used when a thread has terminated. We no longer need to keep track of the actions of the other threads as thread |t| will not obtain the lock again. 
\end{itemize}

At each point in time |b| (\emph{b}efore) is the set of states that have completed their doorway section before |t| started its doorway section; these threads must acquire the lock before |t| can acquire it under the definition of first-come-first-served. |bn| (\emph{b}efore \emph{n}ext) is used to store the set of threads that completed their doorway section after |t|; once |t| acquires the lock all threads in |bn| must acquire the lock before |t| can reacquire it. This specification only enforces that |t| cannot bypass other threads that came first. When the specification is ran in alphabetised parallel across all threads it ensures that no thread can bypass another thread; this therefore ensures that no thread can be bypassed.

\begin{cspm}[caption={The CSP specification for first-come-first-served}, label={CSP:FCFS}]
  FCFSNotStarted(l, t, b, bn) = 
     end.t -> FCFSTerminated(l, t)
  [] callLock.l.t -> FCFSStarted(l, t, lineariz, bn)
  [] doorwayComplete.l?t':diff(ThreadID, union({t}, union(b, bn))) -> FCFSNotStarted(l, t, union(b, {t'}), bn)
  [] lockAcquired.l?t':diff(union(b, bn), {t}) -> FCFSNotStarted(l, t, diff(b, {t'}), bn)


FCFSStarted(l, t, b, bn) = 
     doorwayComplete.l.t -> FCFSCompleted(l, t, b, bn)
  [] doorwayComplete.l?t':diff(ThreadID, union({t}, union(b, bn))) -> FCFSStarted(l, t, b, union(bn, {t'}))
  [] lockAcquired.l?t':diff(union(b, bn), {t}) -> FCFSStarted(l, t, diff(b, {t'}), diff(bn, {t'}))

FCFSCompleted(l, t, b, bn) = 
     empty(b) & lockAcquired.l.t -> FCFSNotStarted(l, t, bn, {})
  [] doorwayComplete.l?t':diff(ThreadID, union({t}, union(b, bn))) -> FCFSCompleted(l, t, b, union(bn, {t'}))
  [] lockAcquired.l?t':diff(union(b, bn), {t}) -> FCFSCompleted(l, t, diff(b, {t'}), diff(bn, {t'}))

FCFSTerminated(l, t) = 
     doorwayComplete.l?t':diff(ThreadID, {t}) -> FCFSTerminated(l, t)
  [] lockAcquired.l?t':diff(ThreadID, {t}) -> FCFSTerminated(l, t)

FCFSCheck(l) = 
  || t <- ThreadID @ [union({callLock.l.t, end.t}, {|doorwayComplete.l, lockAcquired.l|})]
        FCFSNotStarted(l, t, {}, {})
\end{cspm}

We can now verify the Peterson lock implementaion from section \ref{section:peterson-lock} against this property.

\begin{cspm}
PetersonLockDoorway = 
  (PetersonLock 
    [[set.I.2.T.0.x <- doorwayComplete.L.0.T.x | x <- {0, 1}]]) \ InternalChannels

assert FCFSCheck(L.0) [F= PetersonLockDoorway \ {|lockReleased|}
\end{cspm}

This refinement check passes, indicating that the Peterson lock is indeed first-come-first-served and therefore starvation-free. Testing with the TAS and TTAS lock returns that they are not first-come-first-served; this is as expected as they are not starvation-free.

\framebox{Mention other locks?? In table?}

